<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <title>Snake Game</title>
  <script src="/usernode-bridge.js"></script>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    :root {
      --bg: #0b0f16;
      --fg: #e7edf7;
      --muted: #a8b3c7;
      --card: #141b26;
      --border: rgba(255, 255, 255, 0.12);
      --accent: #6ea8fe;
      --primary: #6366f1;
      --primary-hover: #4f46e5;
      --danger: #ff6b6b;
      --ok: #5dd39e;
      --warning: #ffd93d;
    }

    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;
      position: fixed;
    }

    .container {
      display: flex;
      flex-direction: column;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
    }

    /** PC Split-Screen Layout **/
    @media (min-width: 1024px) {
      .game-layout {
        display: flex;
        gap: 0;
        width: 100%;
        height: 100%;
      }

      .game-canvas-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        border-right: 1px solid var(--border);
      }

      .game-info-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        padding: 16px;
        gap: 16px;
      }

      .game-info-panel {
        background: var(--card);
        border: 1px solid var(--border);
        padding: 16px;
        border-radius: 12px;
      }
    }

    /** Mobile - Full canvas **/
    @media (max-width: 1023px) {
      .game-layout {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
      }

      .game-canvas-section {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .game-info-section {
        display: none;
      }

      .game-stats-mobile {
        display: flex;
        justify-content: space-around;
        padding: 8px 12px;
        background: var(--card);
        border-top: 1px solid var(--border);
        font-size: 12px;
        gap: 12px;
      }

      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
      }

      .stat-value {
        font-weight: 700;
        font-size: 16px;
        color: var(--accent);
      }

      .stat-label {
        color: var(--muted);
        font-size: 10px;
      }
    }

    /* Minimal Header */
    .header {
      flex: 0 0 auto;
      padding: 8px 12px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      z-index: 10;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .logo {
      font-weight: 800;
      font-size: 14px;
      background: linear-gradient(135deg, #6EA8FE 0%, #A78BFA 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      white-space: nowrap;
    }

    .header-right {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .wallet-badge {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.05);
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      font-family: monospace;
      color: var(--muted);
    }

    .btn {
      border: none;
      padding: 8px 14px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      touch-action: manipulation;
      background: rgba(99, 102, 241, 0.2);
      color: var(--accent);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    .btn:disabled {
      opacity: 0.5;
    }

    .btn:active {
      background: rgba(99, 102, 241, 0.4);
    }

    /* Main Content */
    .content {
      flex: 1;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    /* Welcome */
    .welcome-screen {
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }

    .welcome-title {
      font-size: 44px;
      font-weight: 900;
      margin-bottom: 12px;
      background: linear-gradient(135deg, #6EA8FE 0%, #A78BFA 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .welcome-text {
      color: var(--muted);
      margin-bottom: 24px;
      font-size: 14px;
    }

    .mode-select-screen {
      align-items: center;
      justify-content: center;
      padding: 16px;
      gap: 16px;
    }

    .modes-grid {
      display: grid;
      gap: 12px;
      width: 100%;
      max-width: 480px;
    }

    .mode-card {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 18px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
    }

    .mode-card:active { transform: scale(0.97); }

    .mode-card:hover {
      border-color: var(--accent);
      background: rgba(110, 168, 254, 0.05);
    }

    .mode-icon { font-size: 32px; margin-bottom: 6px; }
    .mode-title { font-weight: 700; font-size: 18px; margin-bottom: 4px; }
    .mode-desc { font-size: 13px; color: var(--muted); }

    /** Schedule Selection Screen **/
    .schedule-screen {
      align-items: center;
      justify-content: center;
      padding: 16px;
      gap: 16px;
      width: 100%;
    }

    .schedule-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
      width: 100%;
      max-width: 480px;
    }

    .schedule-title {
      font-size: 20px;
      font-weight: 700;
      text-align: center;
      color: var(--fg);
    }

    .schedule-subtitle {
      font-size: 13px;
      color: var(--muted);
      text-align: center;
    }

    .schedule-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .schedule-slot {
      background: var(--card);
      border: 2px solid var(--border);
      padding: 14px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .schedule-slot:active { transform: scale(0.95); }

    .schedule-slot:hover {
      border-color: var(--accent);
      background: rgba(110, 168, 254, 0.05);
    }

    .schedule-slot.available {
      border-color: var(--ok);
      background: rgba(93, 211, 158, 0.05);
    }

    .schedule-slot.available:hover {
      border-color: var(--ok);
      background: rgba(93, 211, 158, 0.15);
    }

    .schedule-slot.queued {
      border-color: var(--primary);
      background: rgba(99, 102, 241, 0.1);
    }

    .schedule-time {
      font-weight: 700;
      font-size: 16px;
      color: var(--accent);
    }

    .schedule-status {
      font-size: 11px;
      color: var(--muted);
    }

    .schedule-status.available {
      color: var(--ok);
    }

    .schedule-status.queued {
      color: var(--primary);
    }

    .schedule-queued-text {
      font-size: 10px;
      color: var(--primary);
      margin-top: 2px;
    }

    /* Game Screen - MAXIMIZED */
    .game-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }

    .game-canvas-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      width: 100%;
      min-height: 0;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      border: none;
      box-shadow: none;
    }

    .game-overlay {
      position: absolute;
      top: 6px;
      left: 6px;
      display: flex;
      gap: 8px;
      z-index: 5;
      pointer-events: none;
    }

    .game-stat {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 700;
      text-align: center;
      backdrop-filter: blur(4px);
    }

    .stat-label {
      font-size: 8px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 16px;
      color: var(--accent);
    }

    .exit-btn {
      position: absolute;
      bottom: 6px;
      right: 6px;
      background: rgba(255, 107, 107, 0.1);
      color: var(--danger);
      border: 1px solid rgba(255, 107, 107, 0.3);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      z-index: 15;
      pointer-events: auto;
      touch-action: manipulation;
    }

    .exit-btn:active {
      background: rgba(255, 107, 107, 0.2);
    }

    /* Battle Panel */
    .battle-panel {
      position: absolute;
      top: 40px;
      right: 6px;
      width: 100px;
      max-height: calc(100% - 50px);
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .player-card {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 6px;
      font-size: 10px;
      flex-shrink: 0;
    }

    .player-row {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 2px;
    }

    .player-dot {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      flex-shrink: 0;
    }

    .player-name {
      flex: 1;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-status {
      font-size: 8px;
      color: var(--danger);
    }

    .player-stat-line {
      font-size: 9px;
      color: var(--muted);
    }

    /* Progress Bar */
    .tx-progress {
      position: absolute;
      bottom: 4px;
      left: 4px;
      right: 4px;
      height: 6px;
      border-radius: 3px;
      background: rgba(0, 0, 0, 0.3);
      overflow: hidden;
      z-index: 20;
    }

    .tx-fill {
      height: 100%;
      width: 0%;
      background: var(--accent);
      transition: width 0.4s ease-out, background-color 0.4s ease;
      border-radius: 3px;
    }

    .tx-fill.ok { background: var(--ok); }
    .tx-fill.warn { background: var(--warning); }
    .tx-fill.err { background: var(--danger); }

    /* Game Over */
    .game-over-screen {
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }

    .game-over-score {
      font-size: 64px;
      font-weight: 900;
      color: var(--accent);
      margin: 16px 0;
      text-shadow: 0 0 30px rgba(110, 168, 254, 0.3);
    }

    .leaderboard {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      width: 100%;
      max-width: 480px;
      max-height: 40vh;
      display: flex;
      flex-direction: column;
      margin: 12px 0;
    }

    .lb-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
    }

    .lb-tab {
      flex: 1;
      background: transparent;
      border: none;
      padding: 10px;
      color: var(--muted);
      font-weight: 600;
      cursor: pointer;
      font-size: 12px;
      border-bottom: 2px solid transparent;
      touch-action: manipulation;
    }

    .lb-tab.active {
      color: var(--fg);
      border-bottom-color: var(--accent);
      background: rgba(255, 255, 255, 0.02);
    }

    .lb-list {
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1;
    }

    .lb-row {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      gap: 8px;
      font-size: 12px;
    }

    .lb-rank {
      width: 20px;
      text-align: center;
      font-weight: 700;
    }

    .lb-info {
      flex: 1;
      min-width: 0;
    }

    .lb-name {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .lb-addr {
      font-size: 10px;
      color: var(--muted);
      font-family: monospace;
    }

    .lb-score {
      font-weight: 700;
      color: var(--accent);
      flex-shrink: 0;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      backdrop-filter: blur(4px);
      padding: 16px;
    }

    .modal-box {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      width: 100%;
      max-width: 420px;
      max-height: 85vh;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 20px;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--muted);
      cursor: pointer;
      touch-action: manipulation;
    }

    .modal-body {
      font-size: 13px;
      line-height: 1.6;
    }

    .modal-body h3 {
      font-size: 14px;
      margin: 12px 0 6px;
      color: var(--fg);
    }

    .modal-body p {
      margin: 6px 0;
    }

    .modal-body ul {
      padding-left: 16px;
      margin: 6px 0;
    }

    .modal-body li {
      margin: 4px 0;
    }

    .modal-buttons {
      display: flex;
      gap: 8px;
      margin-top: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    @media (min-width: 800px) {
      .header {
        padding: 10px 16px;
      }

      .logo {
        font-size: 16px;
      }

      .btn {
        font-size: 13px;
        padding: 10px 16px;
      }

      .welcome-title {
        font-size: 52px;
      }

      .stat-value {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    const GRID_SIZE = 20;
    const GAME_LOOP_INTERVAL = 200;
    const CLASSIC = 'classic';
    const RANKED = 'ranked';
    const BATTLE = 'battle';
    const DAILY = 'daily';
    const BATTLE_COLORS = ['#ff6b6b', '#ffd93d', '#6bcf7f', '#4d96ff', '#c74ce6'];

    const APP_PUBKEY = localStorage.getItem('snake:app_pubkey') || 'ut1zvhmxlhmv95cgzaph6cpv0rrcrn29gr4xkdj9fuykc6648hmvgksmkfua6';
    const TX_SEND_OPTS = { timeoutMs: 90000, pollIntervalMs: 1500 };
    const TX_PB_EXPECTED_S = 30, TX_PB_WARN_S = 45, TX_PB_ERR_S = 90;

    /**
     * Schedule Management System
     * Generates random session times and manages game scheduling queues
     * Prevents overlapping sessions and enables queue joining for future sessions
     */

    async function fetchSchedules(mode) {
      try {
        const resp = await fetch(`/__schedule?mode=${encodeURIComponent(mode)}`);
        const data = await resp.json();
        return (data.schedules || []).sort((a, b) => a.startTime - b.startTime);
      } catch (e) {
        // fallback to client-side generation if server unreachable
        const now = new Date();
        const schedules = [];
        let t = now.getTime();
        for (let i = 0; i < 6; i++) {
          if (mode === BATTLE) {
            const offset = (3 + Math.random() * 2) * 3600 * 1000;
            t += offset;
          } else {
            t += 4 * 60 * 60 * 1000;
          }
          schedules.push({
            id: `${mode}_${i}`,
            startTime: t,
            displayTime: new Date(t).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            players: 0,
            status: t <= now.getTime() ? 'active' : 'waiting'
          });
        }
        return schedules;
      }
    }

    function formatScheduleTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = timestamp - now.getTime();
      const diffMins = Math.ceil(diffMs / 60000);

      if (diffMins <= 0) return 'Starting now';
      if (diffMins < 2) return 'Starting soon';
      if (diffMins < 60) return `In ${diffMins} min`;

      const hours = Math.floor(diffMins / 60);
      const mins = diffMins % 60;
      return `${hours}h ${mins}m`;
    }

    function formatCountdown(timestamp) {
      const diff = Math.max(0, Math.floor((timestamp - Date.now()) / 1000));
      const h = Math.floor(diff / 3600);
      const m = Math.floor((diff % 3600) / 60);
      const s = diff % 60;
      if (h > 0) return `${h}h ${String(m).padStart(2,'0')}m`;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function isScheduleAvailable(scheduleId, queuedSet) {
      if (queuedSet.size > 0 && !queuedSet.has(scheduleId)) return false;
      return !queuedSet.has(scheduleId);
    }

    let _pbRaf = null, _pbStart = 0;

    function pbPercent(s) {
      if (s <= TX_PB_EXPECTED_S) return 95 * (1 - Math.pow(1 - s / TX_PB_EXPECTED_S, 3));
      return 95 + 5 * (1 - Math.exp(-(s - TX_PB_EXPECTED_S) / 120));
    }

    function pbApply(pct) {
      const pb = document.getElementById('txProgress');
      if (!pb) return;
      const fill = pb.querySelector('.tx-fill');
      if (fill) fill.style.width = pct + '%';
    }

    function startProgressBar() {
      const pb = document.getElementById('txProgress');
      if (!pb) return;
      pb.classList.remove('hide');
      _pbStart = performance.now();
      (function tick() {
        const s = (performance.now() - _pbStart) / 1000;
        pbApply(pbPercent(s));
        _pbRaf = requestAnimationFrame(tick);
      })();
    }

    function completeProgressBar() {
      if (_pbRaf) cancelAnimationFrame(_pbRaf);
      const pb = document.getElementById('txProgress');
      if (pb) {
        pb.querySelector('.tx-fill').style.width = '100%';
        pb.querySelector('.tx-fill').className = 'tx-fill ok';
      }
    }

    function App() {
      const [screen, setScreen] = useState('welcome');
      const [mode, setMode] = useState(null);
      const [gameState, setGameState] = useState(null);
      const [playing, setPlaying] = useState(false);
      const [score, setScore] = useState(0);
      const [time, setTime] = useState(null);
      const [timeMax, setTimeMax] = useState(null);
      const [players, setPlayers] = useState(null);
      const [addr, setAddr] = useState(null);
      const [connected, setConnected] = useState(false);
      const [ws, setWs] = useState(null);
      const [leaderboard, setLeaderboard] = useState([]);
      const [battleBoard, setBattleBoard] = useState([]);
      const [activeTab, setActiveTab] = useState('ranked');
      const [submitting, setSubmitting] = useState(false);
      const [showHelp, setShowHelp] = useState(false);
      const [schedules, setSchedules] = useState([]);
      const [selectedSchedule, setSelectedSchedule] = useState(null);
      const [queuedSchedules, setQueuedSchedules] = useState(new Set());
      const [showProfile, setShowProfile] = useState(false);
      const [username, setUsername] = useState(localStorage.getItem('snake:username') || '');
      const [waitingInfo, setWaitingInfo] = useState({});
      const [showLeaveConfirm, setShowLeaveConfirm] = useState(null);
      const [showClassicSave, setShowClassicSave] = useState(false);

      const canvasRef = useRef(null);
      const gameLoopRef = useRef(null);
      const timerRef = useRef(null);
      const dailyRngRef = useRef(null);

      useEffect(() => {
        const a = localStorage.getItem('snake:user_address');
        if (a) {
          setAddr(a);
          setConnected(true);
        } else {
          connectWallet();
        }
        fetchBoards();
        const interval = setInterval(fetchBoards, 5000);
        return () => clearInterval(interval);
      }, []);

      useEffect(() => {
        if (!addr) return;
        fetch(`/__snake/profile?address=${encodeURIComponent(addr)}`).then(r => r.json()).then(data => {
          if (data && data.username) {
            setUsername(data.username);
            localStorage.setItem('snake:username', data.username);
          }
        }).catch(() => {});
      }, [addr]);

      useEffect(() => {
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const wsUrl = `${protocol}://${window.location.host}/__battle`;
        const socket = new WebSocket(wsUrl);
        socket.onopen = () => setConnected(true);
        socket.onclose = () => setConnected(false);
        socket.onmessage = (evt) => {
          try {
            const msg = JSON.parse(evt.data);
            if (msg.type === 'joined_schedule') {
              console.log('[WS] Joined schedule queue, waiting for start');
            } else if (msg.type === 'schedule_state') {
              setWaitingInfo(prev => ({ ...prev, [msg.scheduleId]: { startTime: msg.startTime, players: msg.players || [] } }));
            } else if (msg.type === 'waiting_for_start') {
              console.log('[WS] Waiting room created, countdown starting');
            } else if (msg.type === 'game_starting') {
              console.log('[WS] Battle starting - beginning countdown');
            } else if (msg.type === 'room_state') {
              if (msg.state && msg.state.gameState) {
                console.log('[WS] Room state:', msg.state.gameState.status);
              }
            } else if (msg.type === 'game_started') {
              handleScheduleStart(msg.scheduleId || selectedSchedule);
            } else if (msg.type === 'error') {
              console.error('[WS] Error:', msg.message);
            }
          } catch (e) {
            console.error('[WS] Message parse error', e);
          }
        };
        setWs(socket);
        return () => socket.close();
      }, []);

      useEffect(() => {
        const t = setInterval(() => {
          setSchedules(s => s ? s.map(sch => ({ ...sch })) : s);
        }, 1000);
        return () => clearInterval(t);
      }, []);

      const fetchBoards = async () => {
        try {
          const res = await fetch('/__snake/leaderboard');
          if (res.ok) {
            const data = await res.json();
            setLeaderboard(data.scores || []);
            setBattleBoard(data.battleScores || []);
          }
        } catch (e) {
          console.error('Leaderboard fetch failed:', e);
        }
      };

      const saveClassicScore = async () => {
        try {
          const usernameVal = localStorage.getItem('snake:username') || `user_${addr.slice(-6)}`;
          const memo = JSON.stringify({ app: 'snake', type: 'classic_save', score, timestamp: Date.now(), username: usernameVal });
          if (memo.length > 1024) throw new Error('Payload too large');
          startProgressBar();
          await window.usernode.sendTransaction(APP_PUBKEY, 1, memo, TX_SEND_OPTS);
          completeProgressBar();
          setShowClassicSave(false);
        } catch (e) {
          console.error('Save failed', e);
          setShowClassicSave(false);
        }
      };

      const saveUsernameToChain = async (name) => {
        try {
          const memo = JSON.stringify({ app: 'snake', type: 'set_username', username: name });
          if (memo.length > 1024) throw new Error('Payload too large');
          startProgressBar();
          await window.usernode.sendTransaction(APP_PUBKEY, 1, memo, TX_SEND_OPTS);
          completeProgressBar();
          localStorage.setItem('snake:username', name);
          setUsername(name);
          setShowProfile(false);
          if (addr) fetch(`/__snake/profile?address=${encodeURIComponent(addr)}`);
        } catch (e) {
          console.error('username save failed', e);
        }
      };

      function seededRandom(seed) {
        let s = seed >>> 0;
        return function() {
          s = (s * 1664525 + 1013904223) >>> 0;
          return (s & 0x7fffffff) / 0x80000000;
        };
      }

      function getDailySeed() {
        const d = new Date();
        const key = d.toISOString().slice(0,10);
        let seed = 0;
        for (let i = 0; i < key.length; i++) seed = (seed * 31 + key.charCodeAt(i)) >>> 0;
        return seed;
      }

      const connectWallet = async () => {
        try {
          if (window.usernode?.getNodeAddress) {
            const a = await window.usernode.getNodeAddress();
            setAddr(a);
            setConnected(true);
            localStorage.setItem('snake:user_address', a);
          } else {
            // Fallback: generate mock address for local dev mode
            const mockAddr = localStorage.getItem('usernode:mockAddress') || 
              'ut1_local_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('usernode:mockAddress', mockAddr);
            setAddr(mockAddr);
            setConnected(true);
            localStorage.setItem('snake:user_address', mockAddr);
          }
        } catch (err) {
          console.error('Wallet connection failed:', err);
          // Fallback on error
          const mockAddr = 'ut1_local_' + Math.random().toString(36).substr(2, 9);
          localStorage.setItem('usernode:mockAddress', mockAddr);
          setAddr(mockAddr);
          setConnected(true);
          localStorage.setItem('snake:user_address', mockAddr);
        }
      };

      const initGame = () => {
        const snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }];
        let food;
        if (mode === DAILY) {
          const rnd = dailyRngRef.current || seededRandom(getDailySeed());
          food = { x: Math.floor(rnd() * GRID_SIZE), y: Math.floor(rnd() * GRID_SIZE) };
        } else {
          food = { x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE) };
        }
        setGameState({ snake, food, dir: 'RIGHT', nextDir: 'RIGHT' });
        setScore(0);
      };

      const initBattle = () => {
        const playerSnake = [{ x: 10, y: 10 }, { x: 9, y: 10 }];
        const battlePlayers = [{
          id: 0,
          snake: playerSnake,
          dir: 'RIGHT',
          nextDir: 'RIGHT',
          food: 0,
          alive: true,
          time: 180,
          isRealPlayer: true
        }];
        const foodPosition = { x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE) };
        setPlayers(battlePlayers);
        setGameState({ food: foodPosition });
      };

      const startGame = async (m) => {
        setMode(m);
        if (m === DAILY) {
          dailyRngRef.current = seededRandom(getDailySeed());
          setScreen('playing');
          initGame();
          setPlaying(true);
          return;
        }
        if (m === RANKED || m === BATTLE) {
          const upcomingSchedules = await fetchSchedules(m);
          setSchedules(upcomingSchedules);
          setScreen('schedule');
          return;
        }
        setScreen('playing');
        initGame();
        setPlaying(true);
      };

      const joinSchedule = (scheduleId) => {
        if (queuedSchedules.size > 0 && !queuedSchedules.has(scheduleId)) return;
        setQueuedSchedules(prev => new Set([...prev, scheduleId]));
        setSelectedSchedule(scheduleId);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'join_schedule', scheduleId, mode, playerId: addr }));
        } else {
          const schedule = schedules.find(s => s.id === scheduleId);
          if (schedule) {
            const waitTime = Math.max(0, schedule.startTime - new Date().getTime());
            setTimeout(() => {
              handleScheduleStart(scheduleId);
            }, Math.min(waitTime, 3000));
          }
        }
      };

      const leaveScheduleWithConfirm = (scheduleId) => {
        setShowLeaveConfirm(scheduleId);
      };

      const confirmLeave = (scheduleId) => {
        setQueuedSchedules(prev => {
          const nxt = new Set(prev);
          nxt.delete(scheduleId);
          return nxt;
        });
        setShowLeaveConfirm(null);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'leave_schedule', scheduleId, playerId: addr }));
        }
      };

      function handleScheduleStart(scheduleId) {
        setQueuedSchedules(prev => {
          const nxt = new Set(prev);
          nxt.delete(scheduleId);
          return nxt;
        });
        const schedule = schedules.find(s => s.id === scheduleId);
        setScreen('playing');
        if (mode === RANKED) {
          setTimeMax(30);
          setTime(30);
          initGame();
        } else if (mode === BATTLE) {
          initBattle();
        }
        setPlaying(true);
      }

      // Game Loop
      useEffect(() => {
        if (!playing || !gameState || (mode === BATTLE && !players)) return;

        const tick = () => {
          if (mode === BATTLE) {
            setPlayers(pp => {
              if (!pp) return pp;
              const updated = pp.map(p => {
                if (!p.alive) return p;

                let dir = p.nextDir;
                if ((dir === 'UP' && p.dir === 'DOWN') || (dir === 'DOWN' && p.dir === 'UP') ||
                    (dir === 'LEFT' && p.dir === 'RIGHT') || (dir === 'RIGHT' && p.dir === 'LEFT')) {
                  dir = p.dir;
                }

                const h = p.snake[0];
                let nx = h.x, ny = h.y;
                if (dir === 'UP') ny--;
                else if (dir === 'DOWN') ny++;
                else if (dir === 'LEFT') nx--;
                else nx++;
                nx = (nx + GRID_SIZE) % GRID_SIZE;
                ny = (ny + GRID_SIZE) % GRID_SIZE;

                if (p.snake.some(s => s.x === nx && s.y === ny)) return { ...p, alive: false };

                const ns = [{ x: nx, y: ny }, ...p.snake];
                if (nx === gameState.food.x && ny === gameState.food.y) {
                  return { ...p, snake: ns, food: p.food + 1, dir };
                }
                ns.pop();
                return { ...p, snake: ns, dir };
              });

              const alive = updated.filter(p => p.alive).length;
              if (alive <= 1) setPlaying(false);
              return updated;
            });

            setGameState(prev => {
              const allSegs = players?.filter(p => p.alive).flatMap(p => p.snake) || [];
              if (allSegs.some(s => s.x === prev.food.x && s.y === prev.food.y)) return prev;
              let nf;
              do {
                const r = mode === DAILY && dailyRngRef.current ? dailyRngRef.current() : Math.random();
                const r2 = mode === DAILY && dailyRngRef.current ? dailyRngRef.current() : Math.random();
                nf = { x: Math.floor(r * GRID_SIZE), y: Math.floor(r2 * GRID_SIZE) };
              } while (allSegs.some(s => s.x === nf.x && s.y === nf.y));
              return { ...prev, food: nf };
            });
          } else {
            setGameState(prev => {
              let dir = prev.nextDir;
              if ((dir === 'UP' && prev.dir === 'DOWN') || (dir === 'DOWN' && prev.dir === 'UP') ||
                  (dir === 'LEFT' && prev.dir === 'RIGHT') || (dir === 'RIGHT' && prev.dir === 'LEFT')) {
                dir = prev.dir;
              }

              const h = prev.snake[0];
              let nx = h.x, ny = h.y;
              if (dir === 'UP') ny--;
              else if (dir === 'DOWN') ny++;
              else if (dir === 'LEFT') nx--;
              else nx++;
              nx = (nx + GRID_SIZE) % GRID_SIZE;
              ny = (ny + GRID_SIZE) % GRID_SIZE;

              if (prev.snake.some(s => s.x === nx && s.y === ny)) {
                setPlaying(false);
                return prev;
              }

              const ns = [{ x: nx, y: ny }, ...prev.snake];

              if (nx === prev.food.x && ny === prev.food.y) {
                setScore(s => s + 10);
                if (mode === RANKED) setTime(t => t + 30);

                let nf;
                do {
                  const r = mode === DAILY && dailyRngRef.current ? dailyRngRef.current() : Math.random();
                  const r2 = mode === DAILY && dailyRngRef.current ? dailyRngRef.current() : Math.random();
                  nf = { x: Math.floor(r * GRID_SIZE), y: Math.floor(r2 * GRID_SIZE) };
                } while (ns.some(s => s.x === nf.x && s.y === nf.y));
                return { ...prev, snake: ns, food: nf, dir };
              }

              ns.pop();
              return { ...prev, snake: ns, dir };
            });
          }
        };

        gameLoopRef.current = setInterval(tick, GAME_LOOP_INTERVAL);
        return () => clearInterval(gameLoopRef.current);
      }, [playing, gameState, mode, players]);

      // Timer
      useEffect(() => {
        if (!playing || (mode !== RANKED && mode !== BATTLE)) return;

        timerRef.current = setInterval(() => {
          if (mode === RANKED) {
            setTime(t => {
              if (t <= 1) {
                setPlaying(false);
                return 0;
              }
              return t - 1;
            });
          } else if (mode === BATTLE) {
            setPlayers(pp => {
              const updated = pp?.map(p => ({
                ...p,
                time: Math.max(0, p.time - 1),
                alive: p.alive && p.time > 1
              })) || [];
              if (updated.filter(p => p.alive).length <= 1) setPlaying(false);
              return updated;
            });
          }
        }, 1000);

        return () => clearInterval(timerRef.current);
      }, [playing, mode]);

      // Input
      useEffect(() => {
        if (!playing) return;

        const handleKey = (e) => {
          const map = {
            ArrowUp: 'UP', ArrowDown: 'DOWN', ArrowLeft: 'LEFT', ArrowRight: 'RIGHT',
            KeyW: 'UP', KeyS: 'DOWN', KeyA: 'LEFT', KeyD: 'RIGHT'
          };
          if (map[e.code]) {
            e.preventDefault();
            if (mode === BATTLE) {
              setPlayers(p => p?.map(pl => pl.id === 0 ? { ...pl, nextDir: map[e.code] } : pl));
            } else {
              setGameState(g => ({ ...g, nextDir: map[e.code] }));
            }
          }
        };

        let touchStart = { x: 0, y: 0 };
        const handleTouch = (e) => {
          if (e.type === 'touchstart') {
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          } else if (e.type === 'touchmove') {
            const dx = e.touches[0].clientX - touchStart.x;
            const dy = e.touches[0].clientY - touchStart.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 10) return;

            const angle = Math.atan2(dy, dx);
            let dir;
            if (angle > -0.785 && angle < 0.785) dir = 'RIGHT';
            else if (angle > 0.785 && angle < 2.356) dir = 'DOWN';
            else if (angle > 2.356 || angle < -2.356) dir = 'LEFT';
            else dir = 'UP';

            if (mode === BATTLE) {
              setPlayers(p => p?.map(pl => pl.id === 0 ? { ...pl, nextDir: dir } : pl));
            } else {
              setGameState(g => ({ ...g, nextDir: dir }));
            }
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
        };

        document.addEventListener('keydown', handleKey);
        canvasRef.current?.addEventListener('touchstart', handleTouch);
        canvasRef.current?.addEventListener('touchmove', handleTouch);

        return () => {
          document.removeEventListener('keydown', handleKey);
          canvasRef.current?.removeEventListener('touchstart', handleTouch);
          canvasRef.current?.removeEventListener('touchmove', handleTouch);
        };
      }, [playing, mode]);

      // Canvas Render
      useEffect(() => {
        if (!canvasRef.current || !gameState) return;

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const parent = canvas.parentElement;
        const w = parent.clientWidth;
        const h = parent.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.scale(dpr, dpr);

        // w and h already set above
        const cellSize = w / GRID_SIZE;

        ctx.fillStyle = '#0a0d12';
        ctx.fillRect(0, 0, w, h);

        ctx.strokeStyle = 'rgba(100, 150, 200, 0.05)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < GRID_SIZE; i++) {
          const p = (i + 1) * cellSize;
          ctx.beginPath();
          ctx.moveTo(p, 0);
          ctx.lineTo(p, h);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, p);
          ctx.lineTo(w, p);
          ctx.stroke();
        }

        if (mode === BATTLE && players) {
          players.forEach((p, i) => {
            if (!p.alive) return;
            const col = BATTLE_COLORS[i];
            p.snake.forEach((seg, j) => {
              const x = seg.x * cellSize, y = seg.y * cellSize;
              ctx.fillStyle = j === 0 ? col : col + '88';
              ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
            });
          });
        } else if (gameState.snake) {
          gameState.snake.forEach((seg, i) => {
            const x = seg.x * cellSize, y = seg.y * cellSize;
            if (i === 0) {
              ctx.fillStyle = '#6ea8fe';
            } else {
              ctx.fillStyle = `hsl(${150 + i * 10}, 70%, 50%)`;
            }
            ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
          });
        }

        const f = gameState.food;
        const fx = f.x * cellSize + cellSize / 2, fy = f.y * cellSize + cellSize / 2;
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(fx, fy, cellSize / 2.2, 0, Math.PI * 2);
        ctx.fill();
      }, [gameState, players, mode]);

      // Game Over
      useEffect(() => {
        if (playing || screen !== 'playing') return;

        if (mode === RANKED) {
          submitScore();
        } else if (mode === BATTLE) {
          const w = players?.find(p => p.alive);
          if (w && w.id === 0) submitScore(w.food);
          setScreen('game-over');
        } else {
          setShowClassicSave(true);
          setScreen('game-over');
        }
      }, [playing]);

      const submitScore = async (food = null) => {
        setSubmitting(true);
        try {
          const username = localStorage.getItem('snake:username') || `user_${addr.slice(-6)}`;
          const memo = JSON.stringify({
            app: 'snake',
            type: mode === BATTLE ? 'battle_victory' : 'score_submission',
            score: mode === BATTLE ? food : score,
            mode, timestamp: Date.now(), username
          });
          if (memo.length > 1024) throw new Error('Payload too large');
          startProgressBar();
          await window.usernode.sendTransaction(APP_PUBKEY, 1, memo, TX_SEND_OPTS);
          completeProgressBar();
          setTimeout(() => {
            setScreen('game-over');
            setSubmitting(false);
          }, 1200);
        } catch (err) {
          console.error('Submit failed:', err);
          setScreen('game-over');
          setSubmitting(false);
        }
      };

      // Render
      return (
        <div className="container">
          {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
          {showProfile && (
            <div className="modal-overlay" onClick={() => setShowProfile(false)}>
              <div className="modal-box" onClick={e => e.stopPropagation()}>
                <div className="modal-title">
                  <span>Profile</span>
                  <button className="modal-close" onClick={() => setShowProfile(false)}>√ó</button>
                </div>
                <div className="modal-body">
                  <h3>Display Name</h3>
                  <input value={username} onChange={e => setUsername(e.target.value)} style={{ width: '100%', padding: '8px', marginTop: '8px', borderRadius: '6px', border: '1px solid var(--border)', background: 'transparent', color: 'var(--fg)' }} />
                  <div className="modal-buttons">
                    <button className="btn" onClick={() => saveUsernameToChain(username)}>Save to chain</button>
                    <button className="btn" onClick={() => { localStorage.setItem('snake:username', username); setShowProfile(false); }}>Save locally</button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {showLeaveConfirm && (
            <div className="modal-overlay" onClick={() => setShowLeaveConfirm(null)}>
              <div className="modal-box" onClick={e => e.stopPropagation()}>
                <div className="modal-title">
                  <span>Leave Queue?</span>
                  <button className="modal-close" onClick={() => setShowLeaveConfirm(null)}>√ó</button>
                </div>
                <div className="modal-body">
                  <p>Are you sure you want to leave the waiting room?</p>
                  <div className="modal-buttons">
                    <button className="btn" onClick={() => confirmLeave(showLeaveConfirm)}>Yes, leave</button>
                    <button className="btn" onClick={() => setShowLeaveConfirm(null)}>Cancel</button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {showClassicSave && (
            <div className="modal-overlay" onClick={() => setShowClassicSave(false)}>
              <div className="modal-box" onClick={e => e.stopPropagation()}>
                <div className="modal-title">
                  <span>Save Classic Score</span>
                  <button className="modal-close" onClick={() => setShowClassicSave(false)}>√ó</button>
                </div>
                <div className="modal-body">
                  <p>Do you want to save your classic mode score to the chain?</p>
                  <div className="modal-buttons">
                    <button className="btn" onClick={saveClassicScore}>Save</button>
                    <button className="btn" onClick={() => setShowClassicSave(false)}>No</button>
                  </div>
                </div>
              </div>
            </div>
          )}
          
          <header className="header">
            <div className="logo">üêç Snake</div>
            <div className="header-right">
              {screen !== 'playing' && <button className="btn" onClick={() => setShowHelp(true)}>? Help</button>}
              <button className="btn" onClick={connectWallet} style={{ display: connected ? 'none' : 'inline-flex' }}>
                Wallet
              </button>
              {connected && (
                <>
                  <button className="btn" onClick={() => setShowProfile(true)}>Profile</button>
                  <div className="wallet-badge">
                    ‚úì {addr ? `${addr.slice(0, 5)}...${addr.slice(-6)}` : 'Connected'}
                  </div>
                </>
              )}
            </div>
          </header>

          <div className="content">
            {screen === 'welcome' && (
              <div className="screen welcome-screen">
                <div className="welcome-title">üêç SNAKE</div>
                <div className="welcome-text">Play ‚Ä¢ Earn ‚Ä¢ Compete</div>
                <button className="btn" onClick={() => setScreen('mode-select')} style={{ fontSize: '14px', padding: '10px 24px' }}>
                  PLAY NOW
                </button>
                <div style={{ marginTop: '24px', width: '100%', maxWidth: '480px' }}>
                  <Leaderboard boards={{ leaderboard, battleBoard, activeTab, setActiveTab }} />
                </div>
              </div>
            )}

            {screen === 'mode-select' && (
              <div className="screen mode-select-screen">
                <div>
                  <h2 style={{ fontSize: '20px', marginBottom: '16px', textAlign: 'center' }}>Select Mode</h2>
                  <div className="modes-grid">
                    <div className="mode-card" onClick={() => startGame(CLASSIC)}>
                      <div className="mode-icon">üéÆ</div>
                      <div className="mode-title">Classic</div>
                      <div className="mode-desc">No limit ‚Ä¢ No score saved</div>
                    </div>
                    <div className="mode-card" onClick={() => startGame(RANKED)}>
                      <div className="mode-icon">üèÜ</div>
                      <div className="mode-title">Ranked</div>
                      <div className="mode-desc">Timed ‚Ä¢ Submit to leaderboard</div>
                    </div>
                    <div className="mode-card" onClick={() => startGame(BATTLE)}>
                      <div className="mode-icon">‚öîÔ∏è</div>
                      <div className="mode-title">Battle</div>
                      <div className="mode-desc">Multiplayer ‚Ä¢ Compete vs AI</div>
                    </div>
                    <div className="mode-card" onClick={() => startGame(DAILY)}>
                      <div className="mode-icon">üìÖ</div>
                      <div className="mode-title">Daily Challenge</div>
                      <div className="mode-desc">Same seed for everyone ‚Ä¢ New every day</div>
                    </div>
                  </div>
                  <button className="btn" onClick={() => setScreen('welcome')} style={{ marginTop: '16px' }}>
                    Back
                  </button>
                </div>
              </div>
            )}

            {screen === 'schedule' && (
              <div className="screen schedule-screen">
                <div className="schedule-container">
                  <div className="schedule-title">
                    {mode === RANKED ? 'üèÜ Ranked Sessions' : '‚öîÔ∏è Battle Sessions'}
                  </div>
                  <div className="schedule-subtitle">
                    Join a session or queue for upcoming times
                  </div>

                  <div className="schedule-grid">
                    {schedules.map((sched) => {
                      const isQueued = queuedSchedules.has(sched.id);
                      const hasOther = queuedSchedules.size > 0 && !isQueued;
                      const available = !isQueued && !hasOther;
                      const localDisplay = new Date(sched.startTime).toLocaleString([], { hour: '2-digit', minute: '2-digit' });
                      const wi = waitingInfo[sched.id];
                      const countdown = wi ? formatCountdown(wi.startTime) : formatCountdown(sched.startTime);
                      const playersCount = wi ? (wi.players || []).length : (sched.playerCount || 0);

                      return (
                        <div
                          key={sched.id}
                          className={`schedule-slot ${isQueued ? 'queued' : available ? 'available' : ''}`}
                          onClick={() => available && joinSchedule(sched.id)}
                          style={{ cursor: available ? 'pointer' : 'default', opacity: available ? 1 : 0.55 }}
                        >
                          <div className="schedule-time">{localDisplay}</div>
                          <div className={`schedule-status ${isQueued ? 'queued' : 'available'}`}>
                            {isQueued ? '‚úì Queued' : '„Äá Available'}
                          </div>
                          {isQueued && <div className="schedule-queued-text">You are in queue</div>}
                          <div className="schedule-status" style={{ marginTop: '4px' }}>
                            Starts in {countdown} ‚Ä¢ Players: {playersCount}
                          </div>
                          {isQueued && (
                            <button className="btn" style={{ marginTop: '8px' }} onClick={(e) => { e.stopPropagation(); leaveScheduleWithConfirm(sched.id); }}>
                              Leave Queue
                            </button>
                          )}
                        </div>
                      );
                    })}
                  </div>

                  <button
                    className="btn"
                    onClick={() => {
                      if (queuedSchedules.size > 0) {
                        // Start the game with selected schedule
                        const selected = Array.from(queuedSchedules)[0];
                        joinSchedule(selected);
                      }
                    }}
                    disabled={queuedSchedules.size === 0}
                    style={{ marginTop: '16px' }}
                  >
                    {queuedSchedules.size > 0 ? 'Confirm & Start' : 'Select a time to continue'}
                  </button>

                  <button
                    className="btn"
                    onClick={() => setScreen('mode-select')}
                    style={{ marginTop: '8px', background: 'var(--border)' }}
                  >
                    Back
                  </button>
                </div>
              </div>
            )}

            {screen === 'playing' && (
              <div className="game-layout">
                <div className="game-canvas-section">
                  <div className="game-canvas-area">
                    <canvas ref={canvasRef}></canvas>

                    <div className="game-overlay">
                      <div className="game-stat">
                        <div className="stat-label">Score</div>
                        <div className="stat-value">{score}</div>
                      </div>
                      {mode === RANKED && time !== null && (
                        <div className="game-stat">
                          <div className="stat-label">Time</div>
                          <div className="stat-value">{Math.floor(time / 60)}:{String(time % 60).padStart(2, '0')}</div>
                        </div>
                      )}
                    </div>

                    <button className="exit-btn" onClick={() => {
                      setPlaying(false);
                      clearInterval(gameLoopRef.current);
                      clearInterval(timerRef.current);
                      setScreen('game-over');
                    }}>
                      Exit
                    </button>

                    {mode === BATTLE && players && (
                      <div className="battle-panel">
                        {players.map((p, i) => (
                          <div key={i} className="player-card">
                            <div className="player-row">
                              <div className="player-dot" style={{ background: BATTLE_COLORS[i] }}></div>
                              <div className="player-name">{p.id === 0 ? 'You' : `AI ${p.id}`}</div>
                              {!p.alive && <div className="player-status">OUT</div>}
                            </div>
                            <div className="player-stat-line">Food: {p.food}</div>
                            <div className="player-stat-line">Time: {p.time}s</div>
                          </div>
                        ))}
                      </div>
                    )}

                    <div id="txProgress" className="tx-progress hide" style={{ display: 'none' }}>
                      <div className="tx-fill"></div>
                    </div>
                  </div>

                  {/* Mobile: Stats below canvas */}
                  <div className="game-stats-mobile">
                    <div className="stat-item">
                      <div className="stat-label">Score</div>
                      <div className="stat-value">{score}</div>
                    </div>
                    {mode === RANKED && time !== null && (
                      <div className="stat-item">
                        <div className="stat-label">Time</div>
                        <div className="stat-value">{Math.floor(time / 60)}:{String(time % 60).padStart(2, '0')}</div>
                      </div>
                    )}
                    {mode === BATTLE && players && (
                      <div className="stat-item">
                        <div className="stat-label">Players</div>
                        <div className="stat-value">{players.filter(p => p.alive).length}/{players.length}</div>
                      </div>
                    )}
                  </div>
                </div>

                {/* PC: Info panel on right (50% screen) */}
                <div className="game-info-section">
                  <div className="game-info-panel">
                    <div style={{ fontSize: '14px', fontWeight: '700', marginBottom: '12px' }}>
                      üìä Game Info
                    </div>
                    <div style={{ fontSize: '12px', gap: '8px', display: 'flex', flexDirection: 'column', color: 'var(--muted)' }}>
                      <div>Mode: <span style={{ color: 'var(--accent)' }}>{mode.toUpperCase()}</span></div>
                      <div>Score: <span style={{ color: 'var(--ok)' }}>{score}</span></div>
                      {mode === RANKED && time !== null && (
                        <div>Time: <span style={{ color: 'var(--accent)' }}>
                          {Math.floor(time / 60)}:{String(time % 60).padStart(2, '0')}
                        </span></div>
                      )}
                      {mode === BATTLE && players && (
                        <div>Active Players: <span style={{ color: 'var(--accent)' }}>
                          {players.filter(p => p.alive).length}/{players.length}
                        </span></div>
                      )}
                    </div>
                  </div>

                  {mode === BATTLE && players && (
                    <div className="game-info-panel">
                      <div style={{ fontSize: '14px', fontWeight: '700', marginBottom: '12px' }}>
                        ‚öîÔ∏è Players
                      </div>
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                        {players.map((p, i) => (
                          <div key={i} style={{ fontSize: '12px', padding: '8px', background: 'rgba(255,255,255,0.05)', borderRadius: '6px', borderLeft: `3px solid ${BATTLE_COLORS[i]}` }}>
                            <div style={{ fontWeight: '700' }}>{p.id === 0 ? 'You' : `Player ${p.id}`} {!p.alive && '(OUT)'}</div>
                            <div style={{ color: 'var(--muted)', fontSize: '11px', marginTop: '4px' }}>
                              Food: {p.food} | Time: {p.time}s
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  <div className="game-info-panel">
                    <div style={{ fontSize: '14px', fontWeight: '700', marginBottom: '12px' }}>
                      üéÆ Controls
                    </div>
                    <div style={{ fontSize: '11px', color: 'var(--muted)', lineHeight: '1.6' }}>
                      <div><strong>PC:</strong> Arrow Keys or WASD</div>
                      <div><strong>Mobile:</strong> Drag/Swipe on canvas</div>
                      <div><strong>Pause:</strong> Press Space</div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {screen === 'game-over' && (
              <div className="screen game-over-screen">
                <h2 style={{ fontSize: '24px', marginBottom: '8px' }}>Game Over!</h2>
                <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                  {mode === CLASSIC ? 'Classic Mode' : mode === RANKED ? 'Ranked Mode' : 'Battle Mode'}
                </div>
                <div className="game-over-score">{score}</div>
                <div style={{ marginBottom: '16px', width: '100%' }}>
                  <Leaderboard boards={{ leaderboard, battleBoard, activeTab, setActiveTab }} />
                </div>
                <div style={{ display: 'flex', gap: '8px', justifyContent: 'center', flexWrap: 'wrap' }}>
                  <button className="btn" onClick={() => startGame(mode)} disabled={submitting}>
                    Play Again
                  </button>
                  <button className="btn" onClick={() => setScreen('mode-select')} disabled={submitting}>
                    Change Mode
                  </button>
                  <button className="btn" onClick={() => setScreen('welcome')} disabled={submitting}>
                    Menu
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    function Leaderboard({ boards: { leaderboard, battleBoard, activeTab, setActiveTab } }) {
      const data = activeTab === 'ranked' ? leaderboard : battleBoard;
      return (
        <div className="leaderboard">
          <div className="lb-tabs">
            <button className={`lb-tab ${activeTab === 'ranked' ? 'active' : ''}`} onClick={() => setActiveTab('ranked')}>
              üèÜ Ranked
            </button>
            <button className={`lb-tab ${activeTab === 'battle' ? 'active' : ''}`} onClick={() => setActiveTab('battle')}>
              ‚öîÔ∏è Battle
            </button>
          </div>
          <div className="lb-list">
            {data.length === 0 ? (
              <div style={{ textAlign: 'center', color: 'var(--muted)', padding: '12px', fontSize: '12px' }}>
                No scores yet
              </div>
            ) : (
              data.map((e, i) => (
                <div key={i} className="lb-row">
                  <div className="lb-rank">{i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : i + 1}</div>
                  <div className="lb-info">
                    <div className="lb-name">{e.username || 'Anonymous'}</div>
                    <div className="lb-addr">{e.address?.slice(-8)}</div>
                  </div>
                  <div className="lb-score">{e.score}</div>
                </div>
              ))
            )}
          </div>
        </div>
      );
    }

    function HelpModal({ onClose }) {
      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-box" onClick={e => e.stopPropagation()}>
            <div className="modal-title">
              <span>üêç Help & Controls</span>
              <button className="modal-close" onClick={onClose}>√ó</button>
            </div>
            <div className="modal-body">
              <h3>Controls</h3>
              <p><strong>Mobile:</strong> Drag your finger to control the snake. Swipe in any direction.</p>
              <p><strong>PC:</strong> Use Arrow Keys or WASD to move.</p>

              <h3>Game Modes</h3>
              <ul>
                <li><strong>Classic:</strong> Practice mode with no time limit. Scores don't save.</li>
                <li><strong>Ranked:</strong> Timed challenge. Auto-submits score to leaderboard. 6 games per 24 hours.</li>
                <li><strong>Battle:</strong> 5-player battle. Last snake alive wins! 5 games per 24 hours.</li>
              </ul>

              <h3>Rules</h3>
              <ul>
                <li>Each food = 10 points (Ranked: +30 seconds)</li>
                <li>Snake grows with each food eaten</li>
                <li>Hit your own tail = Game Over</li>
                <li>Walls wrap around - exit one side to enter the opposite</li>
                <li>In Battle: Each AI has random time limit</li>
              </ul>

              <h3>Tips</h3>
              <ul>
                <li>Plan moves ahead to avoid getting trapped</li>
                <li>Use walls strategically</li>
                <li>In Ranked, eat food to add time</li>
              </ul>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
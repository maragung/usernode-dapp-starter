<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snake Game</title>
  <script src="/usernode-bridge.js"></script>
  
  <!-- React & Babel via CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    :root {
      --bg: #0b0f16;
      --fg: #e7edf7;
      --muted: #a8b3c7;
      --card: #141b26;
      --border: rgba(255, 255, 255, 0.12);
      --accent: #6ea8fe;
      --primary: #6366f1;
      --primary-hover: #4f46e5;
      --danger: #ff6b6b;
      --ok: #5dd39e;
      --warning: #ffd93d;
    }

    * {
      box-sizing: border-box;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 600px;
      margin: 0 auto;
      background: var(--bg);
      position: relative;
    }

    /* Header */
    .header {
      padding: 16px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      z-index: 10;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-weight: 800;
      font-size: 18px;
      background: linear-gradient(135deg, #6EA8FE 0%, #A78BFA 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .wallet-info {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      background: rgba(255, 255, 255, 0.05);
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid var(--border);
    }

    .wallet-address {
      font-family: monospace;
      color: var(--muted);
    }

    /* Content Area */
    .content {
      flex: 1;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      overflow-y: auto;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Buttons */
    .btn {
      border: none;
      padding: 12px 24px;
      border-radius: 12px;
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--primary-hover);
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: var(--fg);
      font-size: 14px;
      padding: 8px 16px;
    }

    .btn-secondary:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Welcome Screen */
    .welcome-screen {
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .welcome-title {
      font-size: 42px;
      font-weight: 900;
      margin-bottom: 12px;
      background: linear-gradient(135deg, #6EA8FE 0%, #A78BFA 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .welcome-subtitle {
      color: var(--muted);
      margin-bottom: 32px;
      max-width: 280px;
      line-height: 1.5;
    }

    /* Mode Select */
    .game-modes {
      display: grid;
      gap: 16px;
      width: 100%;
    }

    .mode-card {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 16px;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .mode-card:hover {
      border-color: var(--accent);
      background: rgba(110, 168, 254, 0.05);
      transform: translateY(-2px);
    }

    .mode-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .mode-title {
      font-weight: 700;
      font-size: 18px;
    }

    .mode-description {
      font-size: 13px;
      color: var(--muted);
    }

    /* Game Container */
    .game-container {
      align-items: center;
      justify-content: center;
      padding: 12px;
    }

    canvas {
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      background: #0b0f16;
      touch-action: none;
    }

    .exit-button {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(255, 107, 107, 0.15);
      color: var(--danger);
      border: 1px solid rgba(255, 107, 107, 0.3);
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      z-index: 20;
    }

    .game-stats {
      display: flex;
      gap: 12px;
      width: 100%;
      max-width: 600px;
    }

    .stat-box {
      flex: 1;
      background: var(--card);
      border: 1px solid var(--border);
      padding: 12px;
      border-radius: 12px;
      text-align: center;
    }

    .stat-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 20px;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
    }

    /* Battle Panel */
    .battle-panel {
      background: var(--card);
      border: 1px solid var(--border);
      padding: 8px;
      border-radius: 8px;
    }

    /* Game Over */
    .game-over-screen {
      align-items: center;
      justify-content: center;
      text-align: center;
    }

    .game-over-title {
      font-size: 32px;
      font-weight: 800;
      color: var(--fg);
    }

    .game-over-score {
      font-size: 64px;
      font-weight: 900;
      color: var(--accent);
      margin: 16px 0 32px;
      text-shadow: 0 0 30px rgba(110, 168, 254, 0.3);
    }

    /* Leaderboard */
    .leaderboard-container {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 100%;
      max-height: 400px;
    }

    .leaderboard-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
    }

    .tab-btn {
      flex: 1;
      background: transparent;
      border: none;
      padding: 12px;
      color: var(--muted);
      font-weight: 600;
      cursor: pointer;
      border-bottom: 2px solid transparent;
    }

    .tab-btn.active {
      color: var(--fg);
      border-bottom-color: var(--accent);
      background: rgba(255, 255, 255, 0.02);
    }

    .leaderboard-title {
      padding: 12px;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      text-align: center;
      background: rgba(0, 0, 0, 0.2);
    }

    .leaderboard-list {
      overflow-y: auto;
      flex: 1;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid var(--border);
      gap: 12px;
    }

    .leaderboard-rank {
      width: 24px;
      font-weight: 700;
      text-align: center;
    }

    .rank-1, .rank-2, .rank-3 { font-size: 18px; }

    .leaderboard-player {
      flex: 1;
      overflow: hidden;
    }

    .leaderboard-name {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .leaderboard-addr {
      font-size: 10px;
      color: var(--muted);
      font-family: monospace;
    }

    .leaderboard-score {
      font-weight: 700;
      color: var(--accent);
    }

    .leaderboard-time {
      font-size: 10px;
      color: var(--muted);
      width: 60px;
      text-align: right;
    }

    /* Progress Bar */
    .tx-progress { width: 100%; margin: 8px 0 4px; }
    .tx-progress-track { width: 100%; height: 6px; border-radius: 3px; background: var(--border); overflow: hidden; }
    .tx-progress-fill { height: 100%; width: 0%; border-radius: 3px; background: var(--accent); transition: width 0.4s ease-out, background-color 0.4s ease; }
    .tx-progress-fill.ok { background: var(--ok); }
    .tx-progress-fill.warn { background: var(--warning); }
    .tx-progress-fill.err { background: var(--danger); }
    .tx-progress-label { font-size: 12px; color: var(--muted); margin-top: 4px; text-align: center; }
    .tx-progress-label.warn { color: var(--warning); }
    .tx-progress-label.err { color: var(--danger); }
    .hide { display: none; }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      backdrop-filter: blur(4px);
      padding: 20px;
    }

    .modal-content {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      padding-bottom: 16px;
      margin-bottom: 16px;
    }

    .modal-header h2 {
      margin: 0;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--muted);
      cursor: pointer;
    }

    .modal-body ul {
      padding-left: 20px;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // ============ CONSTANTS ============
    const GRID_SIZE = 20
    const GAME_LOOP_INTERVAL = 200
    const CLASSIC_MODE = 'classic'
    const RANKED_MODE = 'ranked'
    const BATTLE_MODE = 'battle'

    const RANKED_TIME_LIMITS = [30, 60, 90, 120, 180, 300, 600, 900, 1200, 1500, 1800]
    const BATTLE_COLORS = [
      { name: 'Red', hex: '#ff6b6b' },
      { name: 'Yellow', hex: '#ffd93d' },
      { name: 'Green', hex: '#6bcf7f' },
      { name: 'Blue', hex: '#4d96ff' },
      { name: 'Purple', hex: '#c74ce6' },
    ]
    const BATTLE_MAX_PLAYERS = 5
    const BATTLE_INACTIVITY_TIMEOUT = 3 * 60 * 1000

    const APP_PUBKEY = localStorage.getItem('snake:app_pubkey') || 
      'ut1zvhmxlhmv95cgzaph6cpv0rrcrn29gr4xkdj9fuykc6648hmvgksmkfua6'

    const TX_SEND_OPTS = { timeoutMs: 90000, pollIntervalMs: 1500 }
    const TX_PB_EXPECTED_S = 30
    const TX_PB_WARN_S = 45
    const TX_PB_ERR_S = 90

    // ============ PROGRESS BAR HELPERS ============
    let _pbRaf = null
    let _pbStart = 0

    function pbPercent(s) {
      if (s <= TX_PB_EXPECTED_S) {
        const t = s / TX_PB_EXPECTED_S
        return 95 * (1 - Math.pow(1 - t, 3))
      }
      return 95 + 5 * (1 - Math.exp(-(s - TX_PB_EXPECTED_S) / 120))
    }

    function pbApply(pct, s) {
      const el = document.getElementById('txProgress')
      if (!el) return
      const fill = el.querySelector('.tx-progress-fill')
      const label = el.querySelector('.tx-progress-label')
      if (fill) {
        fill.style.width = pct + '%'
        fill.className = 'tx-progress-fill' + (s >= TX_PB_ERR_S ? ' err' : s >= TX_PB_WARN_S ? ' warn' : '')
      }
      if (label) {
        if (s >= TX_PB_ERR_S) {
          label.textContent = 'Taking longer than expected; check Discord'
          label.className = 'tx-progress-label err'
        } else if (s >= TX_PB_WARN_S) {
          label.textContent = 'Taking longer than expected'
          label.className = 'tx-progress-label warn'
        } else {
          label.textContent = 'Submitting score...'
          label.className = 'tx-progress-label'
        }
      }
    }

    function startProgressBar() {
      const el = document.getElementById('txProgress')
      if (el) {
        el.classList.remove('hide')
        const f = el.querySelector('.tx-progress-fill')
        const l = el.querySelector('.tx-progress-label')
        if (f) {
          f.style.width = '0%'
          f.className = 'tx-progress-fill'
        }
        if (l) {
          l.textContent = 'Submitting score...'
          l.className = 'tx-progress-label'
        }
      }
      _pbStart = performance.now()
      (function tick() {
        const s = (performance.now() - _pbStart) / 1000
        pbApply(pbPercent(s), s)
        _pbRaf = requestAnimationFrame(tick)
      })()
    }

    function completeProgressBar() {
      if (_pbRaf) {
        cancelAnimationFrame(_pbRaf)
        _pbRaf = null
      }
      const el = document.getElementById('txProgress')
      if (!el) return
      const f = el.querySelector('.tx-progress-fill')
      const l = el.querySelector('.tx-progress-label')
      if (f) {
        f.className = 'tx-progress-fill ok'
        f.style.width = '100%'
      }
      if (l) {
        l.textContent = 'Score submitted!'
        l.className = 'tx-progress-label'
      }
      setTimeout(() => el.classList.add('hide'), 1200)
    }

    function stopProgressBar() {
      if (_pbRaf) {
        cancelAnimationFrame(_pbRaf)
        _pbRaf = null
      }
    }

    // ============ HELPER FUNCTIONS ============
    function getMedalEmoji(rank) {
      if (rank === 1) return 'ü•á'
      if (rank === 2) return 'ü•à'
      if (rank === 3) return 'ü•â'
      return rank
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60)
      const secs = seconds % 60
      return `${mins}:${String(secs).padStart(2, '0')}`
    }

    function getAiNextDirection(player, food, gridSize) {
      const head = player.snake[0]
      const currentDirection = player.direction

      const possibleMoves = ['UP', 'DOWN', 'LEFT', 'RIGHT'].filter(dir => {
        if (currentDirection === 'UP' && dir === 'DOWN') return false
        if (currentDirection === 'DOWN' && dir === 'UP') return false
        if (currentDirection === 'LEFT' && dir === 'RIGHT') return false
        if (currentDirection === 'RIGHT' && dir === 'LEFT') return false
        return true
      })

      const movesWithScores = possibleMoves.map(dir => {
        let newX = head.x, newY = head.y
        if (dir === 'UP') newY--; if (dir === 'DOWN') newY++;
        if (dir === 'LEFT') newX--; if (dir === 'RIGHT') newX++
        newX = (newX + gridSize) % gridSize
        newY = (newY + gridSize) % gridSize

        const isSuicidal = player.snake.some(seg => seg.x === newX && seg.y === newY)
        if (isSuicidal) return { dir, score: -Infinity }

        const distanceToFood = Math.abs(food.x - newX) + Math.abs(food.y - newY)
        return { dir, score: -distanceToFood }
      })

      movesWithScores.sort((a, b) => b.score - a.score)
      
      if (movesWithScores.length > 0 && movesWithScores[0].score > -Infinity) {
        return movesWithScores[0].dir
      }
      return player.direction
    }

    // ============ MAIN APP COMPONENT ============
    function App() {
      // Screen state
      const [screen, setScreen] = useState('welcome')
      const [gameMode, setGameMode] = useState(null)

      // Game state
      const [gameState, setGameState] = useState(null)
      const [isPlaying, setIsPlaying] = useState(false)
      const [isPaused, setIsPaused] = useState(false)
      const [score, setScore] = useState(0)

      // Time
      const [timeRemaining, setTimeRemaining] = useState(null)
      const [timeLimit, setTimeLimit] = useState(null)

      // Battle mode
      const [battlePlayers, setBattlePlayers] = useState(null)

      // Wallet & UI
      const [userAddress, setUserAddress] = useState(null)
      const [leaderboard, setLeaderboard] = useState([])
      const [battleLeaderboard, setBattleLeaderboard] = useState([])
      const [activeTab, setActiveTab] = useState('ranked')
      const [submitting, setSubmitting] = useState(false)
      const [connected, setConnected] = useState(false)
      const [showExitConfirm, setShowExitConfirm] = useState(false)
      const [showHelp, setShowHelp] = useState(false)

      // Refs
      const canvasRef = useRef(null)
      const gameLoopRef = useRef(null)
      const timerRef = useRef(null)
      const battleInactivityRef = useRef({})
      const lastTapRef = useRef(0)

      // ============ INITIALIZATION ============
      useEffect(() => {
        const addr = localStorage.getItem('snake:user_address')
        if (addr) {
          setUserAddress(addr)
          setConnected(true)
        }

        // Fetch leaderboards
        fetchLeaderboards()
        const leaderboardInterval = setInterval(fetchLeaderboards, 5000)
        return () => clearInterval(leaderboardInterval)
      }, [])

      // ============ WALLET CONNECTION ============
      const connectWallet = async () => {
        try {
          if (window.usernode?.getNodeAddress) {
            const addr = await window.usernode.getNodeAddress()
            setUserAddress(addr)
            setConnected(true)
            localStorage.setItem('snake:user_address', addr)
          }
        } catch (err) {
          console.error('Wallet connection failed:', err)
        }
      }

      // ============ LEADERBOARD ============
      const fetchLeaderboards = async () => {
        try {
          const response = await fetch('/__snake/leaderboard')
          if (response.ok) {
            const data = await response.json()
            setLeaderboard(data.scores || [])
            setBattleLeaderboard(data.battleScores || [])
          }
        } catch (err) {
          console.error('Failed to fetch leaderboard:', err)
        }
      }

      // ============ GAME INITIALIZATION ============
      const initGame = () => {
        const initialSnake = [
          { x: 10, y: 10 },
          { x: 9, y: 10 },
          { x: 8, y: 10 },
        ]
        const food = {
          x: Math.floor(Math.random() * GRID_SIZE),
          y: Math.floor(Math.random() * GRID_SIZE),
        }
        setGameState({
          snake: initialSnake,
          food: food,
          direction: 'RIGHT',
          nextDirection: 'RIGHT',
        })
        setScore(0)
        setIsPaused(false)
      }

      const initBattleGame = () => {
        const positions = [[5, 5], [15, 5], [10, 10], [5, 15], [15, 15]]
        const numPlayers = Math.floor(Math.random() * (BATTLE_MAX_PLAYERS - 1)) + 2

        const players = Array.from({ length: numPlayers }, (_, i) => {
          const [x, y] = positions[i]
          return {
            id: i,
            snake: [{ x, y }, { x: x - 1, y }, { x: x - 2, y }],
            direction: 'RIGHT',
            nextDirection: 'RIGHT',
            food: 0,
            alive: true,
            lastFoodTime: Date.now(),
            timeRemaining: RANKED_TIME_LIMITS[Math.floor(Math.random() * RANKED_TIME_LIMITS.length)],
          }
        })

        let food
        let valid = false
        while (!valid) {
          food = {
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE),
          }
          valid = !players.some((p) => p.snake.some((seg) => seg.x === food.x && seg.y === food.y))
        }

        setBattlePlayers(players)
        setGameState({ food })
        battleInactivityRef.current = {}
        players.forEach((p) => {
          battleInactivityRef.current[p.id] = Date.now()
        })
      }

      const startGame = (mode) => {
        setGameMode(mode)
        if (mode === RANKED_MODE) {
          const limit = RANKED_TIME_LIMITS[Math.floor(Math.random() * RANKED_TIME_LIMITS.length)]
          setTimeLimit(limit)
          setTimeRemaining(limit)
          initGame()
        } else if (mode === BATTLE_MODE) {
          initBattleGame()
        } else {
          initGame()
        }
        setIsPlaying(true)
        setScreen('playing')
      }

      // ============ GAME LOOP (CLASSIC/RANKED) ============
      useEffect(() => {
        if (!isPlaying || !gameState || gameMode === BATTLE_MODE || isPaused) return

        const gameLoop = () => {
          setGameState((prev) => {
            let direction = prev.nextDirection
            
            // Prevent reversal
            if (
              (direction === 'UP' && prev.direction === 'DOWN') ||
              (direction === 'DOWN' && prev.direction === 'UP') ||
              (direction === 'LEFT' && prev.direction === 'RIGHT') ||
              (direction === 'RIGHT' && prev.direction === 'LEFT')
            ) {
              direction = prev.direction
            }

            const head = prev.snake[0]
            let newX = head.x
            let newY = head.y

            switch (direction) {
              case 'UP': newY -= 1; break
              case 'DOWN': newY += 1; break
              case 'LEFT': newX -= 1; break
              case 'RIGHT': newX += 1; break
              default: break
            }

            // Wrap around
            newX = (newX + GRID_SIZE) % GRID_SIZE
            newY = (newY + GRID_SIZE) % GRID_SIZE

            // Check self collision
            if (prev.snake.some((seg) => seg.x === newX && seg.y === newY)) {
              setIsPlaying(false) // Signal game over
              return prev
            }

            const newSnake = [{ x: newX, y: newY }, ...prev.snake]

            // Check food collision
            if (newX === prev.food.x && newY === prev.food.y) {
              setScore((s) => s + 10)
              if (gameMode === RANKED_MODE) {
                setTimeRemaining((t) => t + 30)
              }
              
              let newFood
              do {
                newFood = {
                  x: Math.floor(Math.random() * GRID_SIZE),
                  y: Math.floor(Math.random() * GRID_SIZE),
                }
              } while (newSnake.some((seg) => seg.x === newFood.x && seg.y === newFood.y))

              return {
                ...prev,
                snake: newSnake,
                food: newFood,
                direction: direction,
              }
            }

            newSnake.pop()
            return {
              ...prev,
              snake: newSnake,
              direction: direction,
            }
          })
        }

        gameLoopRef.current = setInterval(gameLoop, GAME_LOOP_INTERVAL)
        return () => clearInterval(gameLoopRef.current)
      }, [isPlaying, gameState, gameMode, isPaused])

      // ============ BATTLE GAME LOOP ============
      useEffect(() => {
        if (!isPlaying || !battlePlayers || gameMode !== BATTLE_MODE || isPaused) return

        const gameLoop = () => {
          setBattlePlayers((players) => {
            if (!players) return players

            const updated = players.map((player) => {
              if (!player.alive) return player

              if (player.id !== 0) {
                player.nextDirection = getAiNextDirection(player, gameState.food, GRID_SIZE)
              }

              let direction = player.nextDirection || player.direction
              
              if (
                (direction === 'UP' && player.direction === 'DOWN') ||
                (direction === 'DOWN' && player.direction === 'UP') ||
                (direction === 'LEFT' && player.direction === 'RIGHT') ||
                (direction === 'RIGHT' && player.direction === 'LEFT')
              ) {
                direction = player.direction
              }

              const head = player.snake[0]
              let newX = head.x
              let newY = head.y

              switch (direction) {
                case 'UP': newY -= 1; break
                case 'DOWN': newY += 1; break
                case 'LEFT': newX -= 1; break
                case 'RIGHT': newX += 1; break
                default: break
              }

              newX = (newX + GRID_SIZE) % GRID_SIZE
              newY = (newY + GRID_SIZE) % GRID_SIZE

              if (player.snake.some((seg) => seg.x === newX && seg.y === newY)) {
                return { ...player, alive: false }
              }

              const newSnake = [{ x: newX, y: newY }, ...player.snake]

              const foodCollided = newX === gameState.food.x && newY === gameState.food.y

              if (foodCollided) {
                battleInactivityRef.current[player.id] = Date.now()
                return {
                  ...player,
                  snake: newSnake,
                  food: player.food + 1,
                  direction: direction,
                  lastFoodTime: Date.now(),
                }
              }

              newSnake.pop()
              return {
                ...player,
                snake: newSnake,
                direction: direction,
              }
            })

            // Check inactivity
            const now = Date.now()
            updated.forEach((player) => {
              if (player.alive && now - battleInactivityRef.current[player.id] > BATTLE_INACTIVITY_TIMEOUT) {
                player.alive = false
              }
            })

            const stillAlive = updated.filter((p) => p.alive)
            if (stillAlive.length === 0 || stillAlive.length === 1) {
              setIsPlaying(false)
            }

            return updated
          })

          setGameState((prev) => {
            const allSnakeSegs = battlePlayers
              .filter((p) => p.alive)
              .flatMap((p) => p.snake)
            const valid = !allSnakeSegs.some((seg) => seg.x === prev.food.x && seg.y === prev.food.y)
            
            if (valid) return prev

            let newFood
            do {
              newFood = {
                x: Math.floor(Math.random() * GRID_SIZE),
                y: Math.floor(Math.random() * GRID_SIZE),
              }
            } while (allSnakeSegs.some((seg) => seg.x === newFood.x && seg.y === newFood.y))

            return { ...prev, food: newFood }
          })
        }

        gameLoopRef.current = setInterval(gameLoop, GAME_LOOP_INTERVAL)
        return () => clearInterval(gameLoopRef.current)
      }, [isPlaying, battlePlayers, gameMode, gameState, isPaused])

      // ============ TIMER (RANKED MODE) ============
      useEffect(() => {
        if (!isPlaying || gameMode !== RANKED_MODE || !timeLimit) return

        timerRef.current = setInterval(() => {
          setTimeRemaining((prev) => {
            if (prev <= 1) {
              clearInterval(timerRef.current)
              setIsPlaying(false) // Signal game over
              return 0
            }
            return prev - 1
          })
        }, 1000)

        return () => clearInterval(timerRef.current)
      }, [isPlaying, gameMode, timeLimit])

      // ============ TIMER (BATTLE MODE) ============
      useEffect(() => {
        if (!isPlaying || gameMode !== BATTLE_MODE || !battlePlayers) return

        timerRef.current = setInterval(() => {
          setBattlePlayers((players) => {
            if (!players) return players
            const updated = players.map((p) => ({
              ...p,
              timeRemaining: Math.max(0, p.timeRemaining - 1),
              alive: p.alive && p.timeRemaining > 1,
            }))
            const stillAlive = updated.filter((p) => p.alive)
            if (stillAlive.length <= 1) {
              setIsPlaying(false)
            }
            return updated
          })
        }, 1000)

        return () => clearInterval(timerRef.current)
      }, [isPlaying, gameMode, battlePlayers])

      // ============ INPUT HANDLING ============
      useEffect(() => {
        if (!isPlaying || !gameState) return

        const handleKeyPress = (e) => {
          if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyS', 'KeyA', 'KeyD', 'Space'].includes(e.code)) {
            return
          }

          e.preventDefault()

          if (e.code === 'Space') {
            setIsPaused((prev) => !prev)
            return
          }

          const directionMap = {
            ArrowUp: 'UP',
            ArrowDown: 'DOWN',
            ArrowLeft: 'LEFT',
            ArrowRight: 'RIGHT',
            KeyW: 'UP',
            KeyS: 'DOWN',
            KeyA: 'LEFT',
            KeyD: 'RIGHT',
          }

          const direction = directionMap[e.code]
          if (direction) {
            handleDirectionChange(direction)
          }
        }

        const handleCanvasDoubleTap = () => {
          const now = Date.now()
          if (now - lastTapRef.current < 300) {
            setIsPaused((prev) => !prev)
          }
          lastTapRef.current = now
        }

        document.addEventListener('keydown', handleKeyPress)
        canvasRef.current?.addEventListener('click', handleCanvasDoubleTap)

        return () => {
          document.removeEventListener('keydown', handleKeyPress)
          canvasRef.current?.removeEventListener('click', handleCanvasDoubleTap)
        }
      }, [isPlaying, gameState, handleDirectionChange])

      const handleDirectionChange = useCallback((direction) => {
        if (!direction) return
        if (gameMode === BATTLE_MODE) {
          setBattlePlayers((prev) => {
            if (!prev) return prev
            return prev.map((p) => (p.id === 0 ? { ...p, nextDirection: direction } : p))
          })
        } else {
          setGameState((prev) => {
            if (!prev) return prev
            return { ...prev, nextDirection: direction }
          })
        }
      }, [gameMode])

      // ============ CANVAS RENDERING ============
      useEffect(() => {
        if (!canvasRef.current || !gameState) return

        const canvas = canvasRef.current
        const ctx = canvas.getContext('2d')

        const rect = canvas.getBoundingClientRect()
        const dpr = window.devicePixelRatio || 1
        canvas.width = rect.width * dpr
        canvas.height = rect.height * dpr
        ctx.scale(dpr, dpr)

        const displayWidth = rect.width
        const displayHeight = rect.height
        const cellSize = displayWidth / GRID_SIZE

        // Background
        ctx.fillStyle = 'rgba(11, 15, 22, 0.3)'
        ctx.fillRect(0, 0, displayWidth, displayHeight)

        // Grid
        ctx.strokeStyle = 'rgba(106, 168, 254, 0.05)'
        ctx.lineWidth = 0.5
        for (let i = 0; i <= GRID_SIZE; i++) {
          const pos = i * cellSize
          ctx.beginPath()
          ctx.moveTo(pos, 0)
          ctx.lineTo(pos, displayHeight)
          ctx.stroke()
          ctx.beginPath()
          ctx.moveTo(0, pos)
          ctx.lineTo(displayWidth, pos)
          ctx.stroke()
        }

        // Draw snakes
        if (gameMode === BATTLE_MODE && battlePlayers) {
          battlePlayers.forEach((player) => {
            const color = BATTLE_COLORS[player.id]?.hex || '#6ea8fe'
            player.snake.forEach((segment, idx) => {
              const x = segment.x * cellSize
              const y = segment.y * cellSize
              if (idx === 0) {
                ctx.fillStyle = color
              } else {
                ctx.fillStyle = `${color}66`
              }
              ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2)
              if (idx === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'
                ctx.fillRect(x + 2, y + 2, cellSize / 3, cellSize / 3)
              }
            })
          })
        } else if (gameState?.snake) {
          gameState.snake.forEach((segment, idx) => {
            const x = segment.x * cellSize
            const y = segment.y * cellSize

            if (idx === 0) {
              const gradient = ctx.createLinearGradient(x, y, x + cellSize, y + cellSize)
              gradient.addColorStop(0, '#6EA8FE')
              gradient.addColorStop(1, '#A78BFA')
              ctx.fillStyle = gradient
            } else {
              const hue = (idx * 10) % 360
              ctx.fillStyle = `hsl(${140 + hue / 10}, 80%, 60%)`
            }

            ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2)

            if (idx === 0) {
              ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'
              ctx.fillRect(x + 2, y + 2, cellSize / 3, cellSize / 3)
            }
          })
        }

        // Draw food
        const food = gameState?.food
        if (food) {
          const fx = food.x * cellSize
          const fy = food.y * cellSize
          const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 300)
          ctx.fillStyle = '#ff6b6b'
          ctx.beginPath()
          ctx.arc(fx + cellSize / 2, fy + cellSize / 2, (cellSize / 2) * pulse, 0, Math.PI * 2)
          ctx.fill()
        }

        // Pause overlay
        if (isPaused) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'
          ctx.fillRect(0, 0, displayWidth, displayHeight)
          ctx.fillStyle = '#ffffff'
          ctx.font = '24px Arial'
          ctx.textAlign = 'center'
          ctx.fillText('PAUSED', displayWidth / 2, displayHeight / 2)
          ctx.font = '14px Arial'
          ctx.fillText('Press SPACE or double tap to resume', displayWidth / 2, displayHeight / 2 + 30)
        }
      }, [gameState, battlePlayers, gameMode, isPaused])

      // ============ GAME OVER HANDLER ============
      useEffect(() => {
        if (isPlaying || screen !== 'playing') return

        if (gameLoopRef.current) clearInterval(gameLoopRef.current)
        if (timerRef.current) clearInterval(timerRef.current)

        if (gameMode === RANKED_MODE) {
          submitScore()
        } else if (gameMode === BATTLE_MODE) {
          const winner = battlePlayers?.find((p) => p.alive)
          if (winner && winner.id === 0) {
            submitBattleScore(winner.food)
          }
          setScreen('game-over')
        } else {
          setScreen('game-over')
        }
      }, [isPlaying])

      const submitScore = async () => {
        setSubmitting(true)

        try {
          const username = localStorage.getItem('snake:username') || `user_${userAddress.slice(-6)}`
          const memo = JSON.stringify({
            app: 'snake',
            type: 'score_submission',
            score: score,
            mode: gameMode,
            timestamp: Date.now(),
            username: username,
          })

          if (memo.length > 1024) {
            throw new Error('Payload too large')
          }

          startProgressBar()
          await window.usernode.sendTransaction(APP_PUBKEY, 1, memo, TX_SEND_OPTS)

          completeProgressBar()
          setTimeout(() => {
            setScreen('game-over')
            setSubmitting(false)
          }, 1500)
        } catch (err) {
          stopProgressBar()
          console.error('Failed to submit score:', err)
          setScreen('game-over')
          setSubmitting(false)
        }
      }

      const submitBattleScore = async (foodCount) => {
        setSubmitting(true)

        try {
          const username = localStorage.getItem('snake:username') || `user_${userAddress.slice(-6)}`
          const memo = JSON.stringify({
            app: 'snake',
            type: 'battle_victory',
            food: foodCount,
            timestamp: Date.now(),
            username: username,
          })

          if (memo.length > 1024) {
            throw new Error('Payload too large')
          }

          startProgressBar()
          await window.usernode.sendTransaction(APP_PUBKEY, 1, memo, TX_SEND_OPTS)

          completeProgressBar()
          setTimeout(() => {
            setSubmitting(false)
          }, 1500)
        } catch (err) {
          stopProgressBar()
          console.error('Failed to submit battle score:', err)
          setSubmitting(false)
        }
      }

      const handleExitRequest = () => {
        setShowExitConfirm(true)
      }

      const confirmExit = () => {
        setShowExitConfirm(false)
        setIsPlaying(false)
        if (gameLoopRef.current) clearInterval(gameLoopRef.current)
        if (timerRef.current) clearInterval(timerRef.current)

        if (gameMode === CLASSIC_MODE) {
          setScreen('mode-select')
        } else if (gameMode === RANKED_MODE) {
          submitScore()
        } else if (gameMode === BATTLE_MODE) {
          const myPlayer = battlePlayers?.find((p) => p.id === 0)
          submitBattleScore(myPlayer ? myPlayer.food : 0)
        }
      }

      // ============ RENDER ============
      return (
        <div className="container">
          {showHelp && <HelpMenu onClose={() => setShowHelp(false)} />}
          {showExitConfirm && (
            <div className="modal-overlay">
              <div className="modal-content" style={{ maxWidth: '300px', textAlign: 'center' }}>
                <h3>Exit Game?</h3>
                <p style={{ marginBottom: '20px', color: 'var(--muted)' }}>
                  {gameMode === CLASSIC_MODE
                    ? 'Progress will be lost.'
                    : 'Your current score will be submitted.'}
                </p>
                <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
                  <button className="btn btn-secondary" onClick={() => setShowExitConfirm(false)}>
                    Cancel
                  </button>
                  <button className="btn btn-primary" onClick={confirmExit}>
                    Confirm
                  </button>
                </div>
              </div>
            </div>
          )}
          <header className="header">
            <div className="header-content">
              <div className="logo">üêç Snake Game</div>
              <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
                <button className="btn btn-secondary" onClick={() => setShowHelp(true)}>
                  Help & Rules
                </button>
                <button className="btn btn-secondary" onClick={connectWallet} style={{ display: connected ? 'none' : 'inline-flex' }}>
                  Connect Wallet
                </button>
                {connected && (
                  <>
                    <div className="wallet-info">
                      <span>‚úì</span>
                      <div className="wallet-address">{userAddress.slice(-8)}</div>
                    </div>
                  </>
                )}
              </div>
            </div>
          </header>

          <div className="content">
            {screen === 'welcome' && (
              <WelcomeScreen
                onPlayClick={() => setScreen('mode-select')}
                leaderboard={leaderboard}
                battleLeaderboard={battleLeaderboard}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
              />
            )}

            {screen === 'mode-select' && (
              <ModeSelectScreen onStartGame={startGame} onBack={() => setScreen('welcome')} />
            )}

            {screen === 'playing' && (
              <GameScreen
                gameMode={gameMode}
                onExit={handleExitRequest}
                canvasRef={canvasRef}
                battlePlayers={battlePlayers}
                score={score}
                timeRemaining={timeRemaining}
              />
            )}

            {screen === 'game-over' && (
              <GameOverScreen
                gameMode={gameMode}
                score={score}
                onPlayAgain={() => startGame(gameMode)}
                onSwitchMode={() => setScreen('mode-select')}
                onMenu={() => setScreen('welcome')}
                submitting={submitting}
                leaderboard={leaderboard}
                battleLeaderboard={battleLeaderboard}
                activeTab={activeTab}
                setActiveTab={setActiveTab}
              />
            )}
          </div>
        </div>
      )
    }

    // ============ SCREEN & UI COMPONENTS ============

    function WelcomeScreen({ onPlayClick, leaderboard, battleLeaderboard, activeTab, setActiveTab }) {
      return (
        <div className="screen welcome-screen">
          <div className="welcome-title">üêç Snake Game</div>
          <div className="welcome-subtitle">Connect your wallet and compete on the leaderboard!</div>
          <button className="btn btn-primary" onClick={onPlayClick}>
            Play Now
          </button>
          <div style={{ marginTop: '20px', width: '100%' }}>
            <Leaderboard
              leaderboard={leaderboard}
              battleLeaderboard={battleLeaderboard}
              activeTab={activeTab}
              setActiveTab={setActiveTab}
            />
          </div>
        </div>
      )
    }

    function ModeSelectScreen({ onStartGame, onBack }) {
      return (
        <div className="screen" style={{ justifyContent: 'center', alignItems: 'center' }}>
          <div style={{ textAlign: 'center' }}>
            <h2 style={{ marginBottom: '24px' }}>Select Game Mode</h2>
            <div className="game-modes">
              <div className="mode-card" onClick={() => onStartGame(CLASSIC_MODE)}>
                <div className="mode-icon">üéÆ</div>
                <div className="mode-title">Classic</div>
                <div className="mode-description">No time limit, no score saved</div>
              </div>
              <div className="mode-card" onClick={() => onStartGame(RANKED_MODE)}>
                <div className="mode-icon">üèÜ</div>
                <div className="mode-title">Ranked</div>
                <div className="mode-description">Random time, auto submit</div>
              </div>
              <div className="mode-card" onClick={() => onStartGame(BATTLE_MODE)}>
                <div className="mode-icon">‚öîÔ∏è</div>
                <div className="mode-title">Battle</div>
                <div className="mode-description">Multiplayer vs AI opponents</div>
              </div>
            </div>
            <button className="btn btn-secondary" onClick={onBack} style={{ marginTop: '24px' }}>
              Back
            </button>
          </div>
        </div>
      )
    }

    function GameScreen({ gameMode, onExit, canvasRef, battlePlayers, score, timeRemaining }) {
      return (
        <div className="screen game-container">
          <button className="exit-button" onClick={onExit}>
            Exit
          </button>
          {gameMode === BATTLE_MODE ? (
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 180px', gap: '12px', flex: 1, minHeight: 0 }}>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', minHeight: 0 }}>
                <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', flex: 1, minHeight: 0 }}>
                  <canvas ref={canvasRef} id="gameCanvas" style={{ maxWidth: '100%' }}></canvas>
                </div>
                <div className="game-stats">
                  <div className="stat-box">
                    <div className="stat-label">Players Alive</div>
                    <div className="stat-value">{battlePlayers?.filter((p) => p.alive).length || 0}</div>
                  </div>
                </div>
              </div>
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', maxHeight: '100%', overflowY: 'auto' }}>
                {battlePlayers?.map((player) => (
                  <div key={player.id} className="battle-panel">
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '4px' }}>
                      <div
                        style={{
                          width: '12px',
                          height: '12px',
                          borderRadius: '2px',
                          background: BATTLE_COLORS[player.id]?.hex,
                        }}
                      ></div>
                      <div style={{ flex: 1, fontSize: '12px', fontWeight: 600 }}>{player.id === 0 ? 'You' : `AI ${player.id}`}</div>
                      {!player.alive && <div style={{ fontSize: '10px', color: 'var(--danger)' }}>OUT</div>}
                    </div>
                    <div style={{ fontSize: '11px', color: 'var(--muted)' }}>
                      Food: <span style={{ color: 'var(--ok)', fontWeight: 'bold' }}>{player.food}</span>
                    </div>
                    <div style={{ fontSize: '11px', color: 'var(--muted)' }}>
                      Time: <span style={{ color: 'var(--warning)' }}>{player.timeRemaining}s</span>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ) : (
            <>
              <div style={{ textAlign: 'center' }}>
                <h3>{gameMode === CLASSIC_MODE ? 'üéÆ Classic Mode' : 'üèÜ Ranked Mode'}</h3>
              </div>
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '12px', flex: 1, minHeight: 0 }}>
                <canvas ref={canvasRef} id="gameCanvas" style={{ aspectRatio: '1/1', maxWidth: '600px', width: '100%' }}></canvas>
                <div className="game-stats">
                  <div className="stat-box">
                    <div className="stat-label">Score</div>
                    <div className="stat-value">{score}</div>
                  </div>
                  {gameMode === RANKED_MODE && timeRemaining !== null && (
                    <div className="stat-box">
                      <div className="stat-label">Time Left</div>
                      <div className="stat-value">{formatTime(timeRemaining)}</div>
                    </div>
                  )}
                </div>
              </div>
            </>
          )}
          <div id="txProgress" className="tx-progress hide">
            <div className="tx-progress-track">
              <div className="tx-progress-fill"></div>
            </div>
            <div className="tx-progress-label">Submitting...</div>
          </div>
        </div>
      )
    }

    function GameOverScreen({ gameMode, score, onPlayAgain, onSwitchMode, onMenu, submitting, leaderboard, battleLeaderboard, activeTab, setActiveTab }) {
      return (
        <div className="screen game-over-screen">
          <div>
            <div className="game-over-title">Game Over!</div>
            <div style={{ marginTop: '16px', fontSize: '14px', color: 'var(--muted)' }}>
              {gameMode === CLASSIC_MODE
                ? 'Classic Mode'
                : gameMode === RANKED_MODE
                ? 'Ranked Mode - Score Submitted!'
                : 'Battle Mode'}
            </div>
          </div>
          <div className="game-over-score">{score}</div>
          <div style={{ marginBottom: '20px', width: '100%', maxHeight: '300px', overflowY: 'auto' }}>
            <Leaderboard
              leaderboard={leaderboard}
              battleLeaderboard={battleLeaderboard}
              activeTab={activeTab}
              setActiveTab={setActiveTab}
            />
          </div>
          <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', flexWrap: 'wrap' }}>
            <button className="btn btn-primary" onClick={onPlayAgain} disabled={submitting}>
              Play Again
            </button>
            <button className="btn btn-secondary" onClick={onSwitchMode} disabled={submitting}>
              Different Mode
            </button>
            <button className="btn btn-secondary" onClick={onMenu} disabled={submitting}>
              Menu
            </button>
          </div>
        </div>
      )
    }

    function HelpMenu({ onClose }) {
      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h2>üêç Help & Rules</h2>
              <button className="close-button" onClick={onClose}>&times;</button>
            </div>
            <div className="modal-body">
              <h3>Controls</h3>
              <p>Use Arrow Keys or WASD to move. Press SPACE to pause. On mobile, swipe to move and double-tap to pause.</p>
              <h3>Game Modes</h3>
              <ul>
                <li><b>Classic:</b> Practice without a time limit. Scores are not saved.</li>
                <li><b>Ranked:</b> Compete against the clock to get a high score on the leaderboard. Your score is automatically submitted.</li>
                <li><b>Battle:</b> Face off against AI opponents. Be the last snake slithering to win!</li>
              </ul>
              <h3>Rules</h3>
              <ul>
                <li>Eating food grows your snake and increases your score.</li>
                <li>In Ranked mode, eating food adds 30 seconds to your timer.</li>
                <li>Running into your own tail ends the game.</li>
                <li>Walls wrap around: exiting one side of the screen makes you appear on the opposite side.</li>
              </ul>
            </div>
          </div>
        </div>
      )
    }

    function Leaderboard({ leaderboard, battleLeaderboard, activeTab, setActiveTab }) {
      const displayBoard = activeTab === 'ranked' ? leaderboard : battleLeaderboard

      return (
        <div className="leaderboard-container">
          <div className="leaderboard-tabs">
            <button className={`tab-btn ${activeTab === 'ranked' ? 'active' : ''}`} onClick={() => setActiveTab('ranked')}>
              üèÜ Ranked
            </button>
            <button className={`tab-btn ${activeTab === 'battle' ? 'active' : ''}`} onClick={() => setActiveTab('battle')}>
              ‚öîÔ∏è Battle
            </button>
          </div>
          <div className="leaderboard-title">{activeTab === 'ranked' ? 'üìä Top Ranked Scores' : '‚öîÔ∏è Top Battle Winners'}</div>
          <div className="leaderboard-list">
            {displayBoard.length === 0 ? (
              <div style={{ textAlign: 'center', color: 'var(--muted)' }}>No scores yet. Be the first!</div>
            ) : (
              displayBoard.map((entry, idx) => (
                <div key={idx} className="leaderboard-item">
                  <div className={`leaderboard-rank rank-${idx + 1}`}>{getMedalEmoji(idx + 1)}</div>
                  <div className="leaderboard-player">
                    <div className="leaderboard-name">{entry.username || 'Anonymous'}</div>
                    <div className="leaderboard-addr">{entry.address.slice(-8)}</div>
                  </div>
                  <div className="leaderboard-score">{entry.score}</div>
                  <div className="leaderboard-time">{new Date(entry.timestamp).toLocaleDateString()}</div>
                </div>
              ))
            )}
          </div>
        </div>
      )
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
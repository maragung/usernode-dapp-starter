<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Falling Sands â€” Shared Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0b0e14;
      color: #cdd6e4;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      height: 100vh;
      height: 100dvh;            /* dynamic viewport height â€” accounts for Safari chrome */
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
    }

    /* â”€â”€ Top bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      width: 100%;
      flex-shrink: 0;
    }

    /* Current element (left side) â€” tap to open picker */
    #current-el {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #current-swatch {
      width: 44px; height: 44px;
      border: 2px solid #fff;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(255,255,255,0.25);
      transition: transform 0.12s;
    }
    #current-el:active #current-swatch { transform: scale(0.92); }
    #current-name {
      font-size: 10px;
      color: #8896ab;
      text-align: center;
      max-width: 52px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Separator */
    .tb-sep { width: 1px; height: 36px; background: rgba(255,255,255,0.12); flex-shrink: 0; }

    /* Quick-access buttons (recent + eraser) */
    .quick-bar {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .quick-btn {
      width: 36px; height: 36px;
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 6px;
      cursor: pointer;
      transition: border-color 0.15s, transform 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      flex-shrink: 0;
    }
    .quick-btn:hover { transform: scale(1.08); }
    .quick-btn:active { transform: scale(0.94); }
    .quick-btn.eraser {
      background: #1e2736;
      font-size: 18px;
      color: #aaa;
    }
    /* Hide the 3 recent-element buttons on narrow screens */
    .quick-btn.recent { flex-shrink: 0; }
    @media (max-width: 420px) {
      .quick-btn.recent { display: none; }
    }

    /* Brush */
    #brush-label { font-size: 11px; color: #8896ab; }
    #brush-size { width: 80px; accent-color: #6ea8fe; }

    /* Send / Discard (right side, hidden until there are pending strokes) */
    .tb-right {
      margin-left: auto;
      display: none;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
    }
    .tb-right.visible { display: flex; }
    .fab {
      width: 34px; height: 34px;
      padding: 0;
      border: none;
      border-radius: 50%;
      font-size: 17px;
      line-height: 34px;
      text-align: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      transition: transform 0.1s;
      flex-shrink: 0;
    }
    .fab:active { transform: scale(0.94); }
    #btn-send {
      background: #5dd39e;
      color: #0b0e14;
    }
    #btn-discard {
      background: #2a3548;
      color: #aaa;
    }
    /* Spinner (shown while transaction is in flight) */
    .spinner {
      width: 20px; height: 20px;
      border-radius: 999px;
      border: 2.5px solid rgba(93,211,158,0.3);
      border-top-color: #5dd39e;
      animation: spin 0.8s linear infinite;
      flex-shrink: 0;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .hide { display: none !important; }
    #budget-meter {
      width: 48px;
      height: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 5px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.15);
    }
    #budget-fill {
      height: 100%;
      width: 100%;
      background: #5dd39e;
      border-radius: 5px;
      transition: width 0.08s, background-color 0.2s;
    }

    /* â”€â”€ Full element picker overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #picker-overlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 100;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      align-items: center;
      justify-content: center;
    }
    #picker-overlay.open { display: flex; }
    #picker-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      padding: 24px;
      max-width: 340px;
      width: 90%;
      max-height: 80vh;
      max-height: 80dvh;
      overflow-y: auto;
      background: #131820;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .picker-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      padding: 8px 4px;
      border-radius: 10px;
      transition: background 0.12s;
      -webkit-tap-highlight-color: transparent;
    }
    .picker-item:hover { background: rgba(255,255,255,0.06); }
    .picker-item:active { background: rgba(255,255,255,0.12); }
    .picker-swatch {
      width: 40px; height: 40px;
      border-radius: 8px;
      border: 2px solid rgba(255,255,255,0.15);
    }
    .picker-item.active .picker-swatch {
      border-color: #fff;
      box-shadow: 0 0 8px rgba(255,255,255,0.3);
    }
    .picker-label {
      font-size: 11px;
      color: #8896ab;
      text-align: center;
    }

    /* â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #canvas-wrap {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      min-height: 0;          /* allow flex child to shrink below content size */
      width: 100%;
    }
    #canvas-container {
      position: relative;
      /* sized dynamically in JS to match the sand canvas */
    }
    #sand-canvas {
      image-rendering: pixelated;
      border-radius: 8px;
      display: block;
      pointer-events: none;   /* overlay canvas handles all input */
    }
    #overlay-canvas {
      position: absolute;
      inset: 0;
      border-radius: 8px;
      cursor: crosshair;
      pointer-events: auto;     /* overlay receives all pointer events */
    }

    /* â”€â”€ Status bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #status-bar {
      padding: 4px 16px;
      flex-shrink: 0;
      font-size: 11px;
      color: #5a6a80;
      font-family: ui-monospace, "SF Mono", Menlo, monospace;
      display: flex;
      gap: 16px;
    }
    #status-bar .ok { color: #5dd39e; }
    #status-bar .err { color: #ff6b6b; }
  </style>
</head>
<body>

<!-- â”€â”€ Status (top, always visible) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="status-bar">
  <span id="status">Connectingâ€¦</span>
  <span id="fps-display"></span>
</div>

<!-- â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="toolbar">
  <div id="current-el">
    <div id="current-swatch"></div>
    <div id="current-name"></div>
  </div>
  <div class="tb-sep"></div>
  <div class="quick-bar" id="quick-bar"></div>
  <label id="brush-label">Brush</label>
  <input id="brush-size" type="range" min="1" max="15" value="4" />
  <div class="tb-right" id="fab-bar">
    <div id="budget-meter">
      <div id="budget-fill"></div>
    </div>
    <button class="fab" id="btn-discard" title="Discard">âœ•</button>
    <button class="fab" id="btn-send" title="Send">âœ“</button>
    <span class="spinner hide" id="send-spinner"></span>
  </div>
</div>

<!-- â”€â”€ Full element picker (hidden) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="picker-overlay">
  <div id="picker-grid"></div>
</div>

<!-- â”€â”€ Canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="canvas-wrap">
  <div id="canvas-container">
    <canvas id="sand-canvas"></canvas>
    <canvas id="overlay-canvas"></canvas>
  </div>
</div>

<!-- â”€â”€ usernode bridge (sendTransaction / getTransactions) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<script src="/usernode-bridge.js"></script>
<!-- â”€â”€ regl from CDN (with fallback) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<script src="https://unpkg.com/regl@2.1.0/dist/regl.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/regl@2.1.0/dist/regl.min.js"></script>
<!-- â”€â”€ pako (zlib inflate) â€” server sends zlib-compressed binary â”€â”€â”€â”€â”€â”€ -->
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ERROR DISPLAY â€” show problems visibly on the page
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.onerror = function(msg, src, line) {
  var el = document.getElementById("status");
  el.className = "err";
  el.textContent = "JS Error (line " + line + "): " + msg;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIGURATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let WIDTH = 300;
let HEIGHT = 450;
const CELL_BYTES = 4;

// â”€â”€ Usernode transaction settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const APP_PUBKEY = "ut1_fallingsands_shared";
const TX_SEND_OPTS = { timeoutMs: 15000, pollIntervalMs: 500 };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SPECIES PALETTE  (id â†’ { name, color })
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const SPECIES = [
  { id: 0,  name: "Erase", color: "#1e2736" },
  { id: 2,  name: "Sand",  color: "#c2b280" },
  { id: 3,  name: "Water", color: "#4a90d9" },
  { id: 13, name: "Stone", color: "#808080" },
  { id: 7,  name: "Wood",  color: "#8b6914" },
  { id: 11, name: "Plant", color: "#4caf50" },
  { id: 19, name: "Seed",  color: "#e91e63" },
  { id: 18, name: "Fungus",color: "#ff8c42" },
  { id: 6,  name: "Fire",  color: "#ff6b35" },
  { id: 8,  name: "Lava",  color: "#ff4500" },
  { id: 9,  name: "Ice",   color: "#a6dcef" },
  { id: 4,  name: "Gas",   color: "#d4d4d4" },
  { id: 12, name: "Acid",  color: "#b8ff00" },
  { id: 16, name: "Oil",   color: "#3a3a3a" },
  { id: 14, name: "Dust",  color: "#ff69b4" },
  { id: 5,  name: "Clone", color: "#9c27b0" },
  { id: 17, name: "Rocket",color: "#ff1744" },
  { id: 15, name: "Mite",  color: "#ce93d8" },
  { id: 1,  name: "Wall",  color: "#555555" },
];

let selectedSpecies = 2; // start with Sand
let brushSize = 4;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ELEMENT SELECTOR â€” current + 3 recent + eraser + full picker
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Default recent: Wall, Water, Fire  (most-recent first)
let recentIds = [1, 3, 6];
const MAX_RECENT = 3;

// Helpers to look up species data by id
const speciesById = {};
SPECIES.forEach(sp => { speciesById[sp.id] = sp; });

// â”€â”€ DOM references â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const currentSwatchEl = document.getElementById("current-swatch");
const currentNameEl   = document.getElementById("current-name");
const currentElBtn    = document.getElementById("current-el");
const quickBar        = document.getElementById("quick-bar");
const pickerOverlay   = document.getElementById("picker-overlay");
const pickerGrid      = document.getElementById("picker-grid");
const brushSlider     = document.getElementById("brush-size");

// â”€â”€ Update the "current element" indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function refreshCurrent() {
  const sp = speciesById[selectedSpecies] || SPECIES[1];
  currentSwatchEl.style.background = sp.color;
  currentNameEl.textContent = sp.name;
}

// â”€â”€ Rebuild the quick-bar (3 recent + eraser) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function refreshQuickBar() {
  quickBar.innerHTML = "";

  // Recent elements
  recentIds.forEach(id => {
    const sp = speciesById[id];
    if (!sp) return;
    const btn = document.createElement("div");
    btn.className = "quick-btn recent";
    btn.style.background = sp.color;
    btn.title = sp.name;
    btn.addEventListener("click", () => selectSpecies(id));
    quickBar.appendChild(btn);
  });

  // Eraser button (ğŸ§¹ eraser emoji)
  const eraser = document.createElement("div");
  eraser.className = "quick-btn eraser";
  eraser.title = "Erase";
  eraser.textContent = "ğŸ§¹";
  eraser.addEventListener("click", () => { selectedSpecies = 0; refreshCurrent(); });
  quickBar.appendChild(eraser);
}

// â”€â”€ Select a species (updates recent list) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function selectSpecies(id) {
  if (id === 0) { selectedSpecies = 0; refreshCurrent(); return; }

  const prev = selectedSpecies;
  selectedSpecies = id;

  // Push the previous selection into recent (if it's a real element)
  if (prev !== 0 && prev !== id) {
    recentIds = recentIds.filter(r => r !== id && r !== prev);
    recentIds.unshift(prev);
    if (recentIds.length > MAX_RECENT) recentIds.length = MAX_RECENT;
  } else {
    // Just remove the newly-selected from recent so it's not duplicated
    recentIds = recentIds.filter(r => r !== id);
    if (recentIds.length > MAX_RECENT) recentIds.length = MAX_RECENT;
  }

  refreshCurrent();
  refreshQuickBar();
}

// â”€â”€ Build the full picker grid (all elements with names) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SPECIES.forEach(sp => {
  if (sp.id === 0) return; // eraser is in the quick-bar, not the picker
  const item = document.createElement("div");
  item.className = "picker-item";
  item.innerHTML =
    `<div class="picker-swatch" style="background:${sp.color}"></div>` +
    `<div class="picker-label">${sp.name}</div>`;
  item.addEventListener("click", () => {
    selectSpecies(sp.id);
    closePicker();
  });
  pickerGrid.appendChild(item);
});

function openPicker() {
  // Highlight the currently selected element in the grid
  const items = pickerGrid.querySelectorAll(".picker-item");
  const nonEraseSpecies = SPECIES.filter(s => s.id !== 0);
  items.forEach((el, i) => {
    el.classList.toggle("active", nonEraseSpecies[i] && nonEraseSpecies[i].id === selectedSpecies);
  });
  pickerOverlay.classList.add("open");
}
function closePicker() { pickerOverlay.classList.remove("open"); }

// Tap current element â†’ open picker
currentElBtn.addEventListener("click", openPicker);

// Tap backdrop â†’ close picker
pickerOverlay.addEventListener("click", (e) => {
  if (e.target === pickerOverlay) closePicker();
});

// â”€â”€ Brush size slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
brushSlider.addEventListener("input", () => {
  brushSize = parseInt(brushSlider.value, 10);
});

// â”€â”€ Initial render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
refreshCurrent();
refreshQuickBar();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const canvas = document.getElementById("sand-canvas");
const overlayCanvas = document.getElementById("overlay-canvas");
const overlayCtx = overlayCanvas.getContext("2d");
const canvasContainer = document.getElementById("canvas-container");

// Forward-declared; real implementation is in the STAGED PAINT section.
// Needed because sizeCanvas() calls it on startup before that section runs.
let redrawOverlay = function() {};

function sizeCanvas() {
  const wrap = document.getElementById("canvas-wrap");
  const maxW = wrap.clientWidth - 8;   // 4px padding each side
  const maxH = wrap.clientHeight - 8;
  // Fit the simulation's aspect ratio into the available space
  const aspect = WIDTH / HEIGHT;
  let w, h;
  if (maxW / maxH > aspect) {
    h = Math.max(1, maxH);
    w = Math.round(h * aspect);
  } else {
    w = Math.max(1, maxW);
    h = Math.round(w / aspect);
  }
  // Container wraps both canvases at display size
  canvasContainer.style.width = w + "px";
  canvasContainer.style.height = h + "px";

  // WebGL canvas
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  canvas.width = WIDTH;
  canvas.height = HEIGHT;

  // 2D overlay canvas (same pixel dimensions as simulation)
  overlayCanvas.style.width = w + "px";
  overlayCanvas.style.height = h + "px";
  overlayCanvas.width = WIDTH;
  overlayCanvas.height = HEIGHT;

  // Re-draw the overlay if there are pending strokes
  redrawOverlay();
}
sizeCanvas();
window.addEventListener("resize", sizeCanvas);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEBGL RENDERER  (regl + the sandspiel fragment shader with glslify inlined)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let cellData = new Uint8Array(WIDTH * HEIGHT * CELL_BYTES);

if (typeof createREGL === "undefined") {
  document.getElementById("status").className = "err";
  document.getElementById("status").textContent =
    "Error: regl library failed to load (CDN unreachable?)";
  throw new Error("regl not loaded");
}

let regl, dataTexture;
try {
  regl = createREGL({ canvas, attributes: { preserveDrawingBuffer: false } });
  // Texture dimensions are swapped (HEIGHT Ã— WIDTH) because the Rust Universe
  // stores cells column-major: index = x * height + y.  Each texture row must
  // hold one full grid column (height entries), so texture width = HEIGHT.
  // Explicit NPOT-safe params for mobile WebGL 1.0 compatibility.
  dataTexture = regl.texture({
    width: HEIGHT, height: WIDTH, data: cellData,
    min: 'nearest', mag: 'nearest',
    wrapS: 'clamp', wrapT: 'clamp',
    format: 'rgba', type: 'uint8',
  });
} catch (e) {
  document.getElementById("status").className = "err";
  document.getElementById("status").textContent =
    "WebGL error: " + e.message;
  throw e;
}

const VERTEX_SHADER = `
precision mediump float;
attribute vec2 position;
varying vec2 uv;
void main() {
  uv = position;
  gl_Position = vec4(position, 0, 1);
}`;

// The fragment shader is sandspiel's sand.glsl with glslify dependencies
// (hsv2rgb, simplex noise 2D/3D) inlined.
const FRAGMENT_SHADER = `
precision mediump float;
uniform float t;
uniform float dpi;
uniform vec2 resolution;
uniform sampler2D data;
varying vec2 uv;

// â”€â”€ hsv2rgb (glsl-hsv2rgb) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
vec3 hsv2rgb(vec3 c) {
  vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// â”€â”€ simplex helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
vec3 mod289_3(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
vec2 mod289_2(vec2 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
vec4 mod289_4(vec4 x) { return x - floor(x * (1.0/289.0)) * 289.0; }
vec3 permute3(vec3 x) { return mod289_3(((x*34.0)+1.0)*x); }
vec4 permute4(vec4 x) { return mod289_4(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

// â”€â”€ simplex 2D (Ashima Arts / webgl-noise) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
float snoise2(vec2 v) {
  const vec4 C = vec4( 0.211324865405187, 0.366025403784439,
                       -0.577350269189626, 0.024390243902439);
  vec2 i  = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);
  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;
  i = mod289_2(i);
  vec3 p = permute3(permute3(i.y + vec3(0.0, i1.y, 1.0))
                             + i.x + vec3(0.0, i1.x, 1.0));
  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                           dot(x12.zw,x12.zw)), 0.0);
  m = m*m; m = m*m;
  vec3 xh = 2.0 * fract(p * C.www) - 1.0;
  vec3 h  = abs(xh) - 0.5;
  vec3 ox = floor(xh + 0.5);
  vec3 a0 = xh - ox;
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
  vec3 g;
  g.x  = a0.x * x0.x  + h.x * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// â”€â”€ simplex 3D (Ashima Arts / webgl-noise) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
float snoise3(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i  = floor(v + dot(v, C.yyy));
  vec3 x0 = v   - i + dot(i, C.xxx);
  vec3 g  = step(x0.yzx, x0.xyz);
  vec3 l  = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;
  i = mod289_3(i);
  vec4 p = permute4(permute4(permute4(
             i.z + vec4(0.0, i1.z, i2.z, 1.0))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0))
           + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;
  vec4 j  = p - 49.0 * floor(p * ns.z * ns.z);
  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_);
  vec4 x  = x_ * ns.x + ns.yyyy;
  vec4 y  = y_ * ns.x + ns.yyyy;
  vec4 hz = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(hz, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
  vec3 p0 = vec3(a0.xy, hz.x);
  vec3 p1 = vec3(a0.zw, hz.y);
  vec3 p2 = vec3(a1.xy, hz.z);
  vec3 p3 = vec3(a1.zw, hz.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.6 - vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot(m*m, vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
}

// â”€â”€ main (sandspiel sand.glsl) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
void main() {
  vec2 textCoord = ((uv * vec2(0.5, -0.5)) + vec2(0.5)).yx;
  vec4 d = texture2D(data, textCoord);
  int type = int((d.r * 255.0) + 0.1);

  float hue = 0.0;
  float saturation = 0.6;
  float lightness = 0.3 + d.g * 0.5;
  float noise = snoise3(vec3(floor(uv * resolution / dpi), t * 0.05));
  float a = 1.0;

  if (type == 0) {        // Empty
    hue = 0.0; saturation = 0.1; lightness = 0.1; a = 0.1;
  } else if (type == 1) { // Wall
    hue = 0.1; saturation = 0.1; lightness = 0.4;
  } else if (type == 2) { // Sand
    hue = 0.1; saturation = 0.5; lightness += 0.3;
  } else if (type == 3) { // Water
    hue = 0.6;
    lightness = 0.7 + d.g * 0.25 + noise * 0.1;
    int polarity = int(mod(d.g * 255.0, 2.0) + 0.1);
    if (polarity == 0) lightness += 0.01;
  } else if (type == 4) { // Gas
    hue = 0.0; lightness += 0.4; saturation = 0.2 + (d.b * 1.5);
  } else if (type == 5) { // Cloner
    hue = 0.9; saturation = 0.3;
  } else if (type == 6) { // Fire
    hue = d.g * 0.1; saturation = 0.7;
    lightness = 0.7 + (d.g * 0.3) + ((noise + 0.8) * 0.5);
  } else if (type == 7) { // Wood
    hue = d.g * 0.1; saturation = 0.3; lightness = 0.3 + d.g * 0.3;
  } else if (type == 8) { // Lava
    hue = d.g * 0.1; lightness = 0.7 + d.g * 0.25 + noise * 0.1;
  } else if (type == 9) { // Ice
    hue = 0.6; saturation = 0.4; lightness = 0.7 + d.g * 0.5;
  } else if (type == 10) { // Sink
    hue = 0.9; saturation = 0.4; lightness = 1.0;
  } else if (type == 11) { // Plant
    hue = 0.4; saturation = 0.4;
  } else if (type == 12) { // Acid
    hue = 0.18; saturation = 0.9; lightness = 0.8 + d.g * 0.2 + noise * 0.05;
  } else if (type == 13) { // Stone
    hue = -0.4 + (d.g * 0.5); saturation = 0.1;
  } else if (type == 14) { // Dust
    hue = (d.g * 2.0) + t * 0.0008; saturation = 0.4; lightness = 0.8;
  } else if (type == 15) { // Mite
    hue = 0.8; saturation = 0.9; lightness = 0.8;
  } else if (type == 16) { // Oil
    hue = (d.g * 5.0) + t * 0.008; saturation = 0.2; lightness = 0.3;
  } else if (type == 17) { // Rocket
    hue = 0.0; saturation = 0.4 + d.b; lightness = 0.9;
  } else if (type == 18) { // Fungus
    hue = (d.g * 0.15) - 0.1;
    saturation = (d.g * 0.8) - 0.05;
    lightness = 1.5 - (d.g * 0.2);
  } else if (type == 19) { // Seed / flower
    hue = fract(fract(d.b * 2.0) * 0.5) - 0.3;
    saturation = 0.7 * (d.g + 0.4) + d.b * 0.2;
    lightness = 0.9 * (d.g + 0.9);
  }

  lightness *= (0.975 + snoise2(floor(uv * resolution / dpi)) * 0.025);
  gl_FragColor = vec4(hsv2rgb(vec3(hue, saturation, lightness)), a);
}`;

const drawSand = regl({
  frag: FRAGMENT_SHADER,
  vert: VERTEX_SHADER,
  uniforms: {
    t: ({ tick }) => tick,
    data: () => dataTexture({
      width: HEIGHT, height: WIDTH, data: cellData,
      min: 'nearest', mag: 'nearest',
      wrapS: 'clamp', wrapT: 'clamp',
    }),
    resolution: ({ viewportWidth, viewportHeight }) => [viewportWidth, viewportHeight],
    dpi: window.devicePixelRatio * 2,
  },
  attributes: {
    position: [[-1, 4], [-1, -1], [4, -1]],
  },
  count: 3,
});

// Render loop (runs at display refresh rate; data arrives at server tick rate)
function renderLoop() {
  regl.poll();
  drawSand();
  requestAnimationFrame(renderLoop);
}
renderLoop();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEBSOCKET â€” Parallel-Racing Strategy
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Safari iOS has a bug where some WebSocket objects never fire onopen.
// Instead of retrying sequentially (slow), we open MULTIPLE sockets in a
// staggered burst.  Whichever fires onopen first wins; the rest are closed.
//
// Timeline of a single "round":
//   0ms   â†’ create socket A
//   200ms â†’ if no winner yet, create socket B
//   400ms â†’ if no winner yet, create socket C
//   800ms â†’ if no winner yet, give up this round and start a new one
//
// Typical result: winner in < 200ms.  Worst case: ~900ms per round.

const statusEl = document.getElementById("status");
const fpsEl = document.getElementById("fps-display");
let ws = null;              // the winning / active socket
let frameCount = 0;
let lastFpsTime = performance.now();
let bytesReceived = 0;
let lastBwTime = performance.now();

// Binary message types (must match server)
const MSG_KEYFRAME = 0x01;
const MSG_DELTA = 0x02;

// Racing parameters (matching the test server that works on Safari)
const WS_STAGGER       = 200;   // ms between parallel socket creations
const WS_POOL_SIZE     = 3;     // max sockets per round
const WS_ROUND_TIMEOUT = 800;   // ms before we give up a round
const WS_ROUND_GAP     = 100;   // ms between rounds
const WS_MAX_ROUNDS    = 20;    // safety limit

let wsRound = 0;
let wsTotalAttempts = 0;

// â”€â”€ Debug log (visible on mobile) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const debugLines = [];
function dbg(msg) {
  const t = (performance.now() / 1000).toFixed(2);
  const line = `[${t}] ${msg}`;
  console.log(line);
  debugLines.push(line);
  if (debugLines.length > 6) debugLines.shift();
  statusEl.textContent = debugLines.join(" | ");
}

// â”€â”€ Handle incoming messages (shared by all sockets) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleMessage(event) {
  if (typeof event.data === "string") {
    // JSON control message (e.g. config)
    try {
      const msg = JSON.parse(event.data);
      if (msg.type === "config") {
        WIDTH = msg.width;
        HEIGHT = msg.height;
        cellData = new Uint8Array(WIDTH * HEIGHT * CELL_BYTES);
        maxBudget = BUDGET_FRACTION * WIDTH * HEIGHT;
        sizeCanvas();
      }
    } catch (_) {}
    return;
  }

  // Server sends zlib-compressed binary; inflate it first
  const compressed = new Uint8Array(event.data);
  bytesReceived += compressed.byteLength;
  let buf;
  if (typeof pako === "undefined") {
    statusEl.className = "err";
    statusEl.textContent = "Error: pako library not loaded";
    return;
  }
  try {
    buf = pako.inflate(compressed);
  } catch (e) {
    console.warn("inflate error:", e.message);
    return;
  }
  const msgType = buf[0];

  if (msgType === MSG_KEYFRAME) {
    cellData.set(buf.subarray(1));
  } else if (msgType === MSG_DELTA) {
    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    const numChanges = view.getUint32(1);
    let pos = 5;
    for (let i = 0; i < numChanges; i++) {
      const offset = view.getUint32(pos); pos += 4;
      cellData[offset]     = buf[pos++];
      cellData[offset + 1] = buf[pos++];
      cellData[offset + 2] = buf[pos++];
      cellData[offset + 3] = buf[pos++];
    }
  }

  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime >= 1000) {
    const kbps = (bytesReceived / 1024 / ((now - lastBwTime) / 1000)).toFixed(1);
    fpsEl.textContent = `${frameCount} fps Â· ${kbps} KB/s`;
    statusEl.className = "ok";
    statusEl.textContent = "Connected";
    frameCount = 0;
    bytesReceived = 0;
    lastFpsTime = now;
    lastBwTime = now;
  }
}

// â”€â”€ Start a new "round" of parallel socket racing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startRound() {
  if (document.visibilityState === "hidden") return;

  wsRound++;
  const rid = wsRound;
  dbg(`round ${rid}`);

  const sockets = [];
  const timers = [];
  let won = false;

  function cleanup(winner) {
    for (const t of timers) clearTimeout(t);
    for (const s of sockets) {
      if (s !== winner) {
        s.onopen = s.onclose = s.onerror = s.onmessage = null;
        try { s.close(); } catch (_) {}
      }
    }
  }

  function createSocket() {
    if (won) return;
    wsTotalAttempts++;
    const aid = wsTotalAttempts;
    const idx = sockets.length + 1;

    const proto = location.protocol === "https:" ? "wss:" : "ws:";
    const url = `${proto}//${location.host}`;
    dbg(`R${rid}.${idx} new WS`);

    const sock = new WebSocket(url);
    sock.binaryType = "arraybuffer";
    sockets.push(sock);

    sock.onopen = () => {
      if (won) {
        // Another socket already won â€” close this one
        sock.onopen = sock.onclose = sock.onerror = sock.onmessage = null;
        try { sock.close(); } catch (_) {}
        return;
      }
      won = true;
      cleanup(sock);
      ws = sock;
      dbg(`R${rid}.${idx} âœ… onopen`);
      statusEl.className = "ok";

      // Tell the server we're ready to receive data
      try {
        sock.send(JSON.stringify({ type: "ready" }));
      } catch (e) {
        dbg(`send-ready err: ${e.message}`);
      }
    };

    sock.onmessage = handleMessage;

    sock.onerror = () => {
      dbg(`R${rid}.${idx} onerror`);
    };

    sock.onclose = (ev) => {
      if (won && sock === ws) {
        // Our active connection died â€” reconnect
        dbg(`close code=${ev.code}`);
        ws = null;
        statusEl.className = "err";
        setTimeout(startRound, WS_ROUND_GAP);
      } else if (!won) {
        dbg(`R${rid}.${idx} close code=${ev.code} (pre-open)`);
      }
      // If won && sock !== ws â†’ leftover, ignore
    };
  }

  // Stagger socket creation
  createSocket(); // immediately
  for (let i = 1; i < WS_POOL_SIZE; i++) {
    timers.push(setTimeout(() => {
      if (!won) createSocket();
    }, WS_STAGGER * i));
  }

  // Round timeout â€” if no winner, close everything and start fresh
  timers.push(setTimeout(() => {
    if (won) return;
    dbg(`R${rid} â° TIMEOUT`);
    cleanup(null);
    if (wsRound < WS_MAX_ROUNDS) {
      setTimeout(startRound, WS_ROUND_GAP);
    } else {
      dbg("Gave up after " + WS_MAX_ROUNDS + " rounds");
      statusEl.className = "err";
      statusEl.textContent = "Connection failed â€” tap to retry";
      document.body.addEventListener("click", () => {
        wsRound = 0;
        startRound();
      }, { once: true });
    }
  }, WS_ROUND_TIMEOUT));
}

// Connect after load + 1 rAF + 50ms (same pattern that works in the test server)
function scheduleConnect() {
  requestAnimationFrame(() => setTimeout(startRound, 50));
}
if (document.readyState === "complete") {
  scheduleConnect();
} else {
  window.addEventListener("load", scheduleConnect);
}

// Reconnect when the page becomes visible again (e.g. user switches back
// to Safari tab, or unlocks phone).  Safari kills WS in background.
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible" && (!ws || ws.readyState !== WebSocket.OPEN)) {
    wsRound = 0;
    setTimeout(startRound, 200);
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STAGED PAINT â€” draw locally, preview as overlay, send on button press
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Each pending stroke is a line segment: {x1,y1, x2,y2, size, species, area}
// A single tap produces a degenerate segment where (x1,y1)==(x2,y2).
let pendingStrokes = [];
let painting = false;
let lastPaintPos = null;            // {x, y} â€” last position during drag
let dragStartIdx = 0;               // index into pendingStrokes where current drag began

const fabBar       = document.getElementById("fab-bar");
const btnSend      = document.getElementById("btn-send");
const btnDiscard   = document.getElementById("btn-discard");
const budgetFill   = document.getElementById("budget-fill");

// â”€â”€ Drawing budget (min of 2% screen area AND 1024-char memo limit) â”€â”€â”€â”€â”€
const BUDGET_FRACTION = 0.02;
const MEMO_MAX_CHARS = 1024;
let maxBudget = BUDGET_FRACTION * WIDTH * HEIGHT;  // recalculated on config
let usedBudget = 0;

// Estimate the pixel area of a capsule-shaped segment
function segmentArea(seg) {
  const r = Math.max(seg.size, 1);
  const dx = seg.x2 - seg.x1;
  const dy = seg.y2 - seg.y1;
  const len = Math.sqrt(dx * dx + dy * dy);
  // Capsule area = rectangle + circle at each end (combined = one full circle)
  return len * r * 2 + Math.PI * r * r;
}

// Compute the memo JSON length for the current pending strokes
function currentMemoLength() {
  const strokes = pendingStrokes.map(s =>
    [s.x1, s.y1, s.x2, s.y2, s.size, s.species]
  );
  return JSON.stringify({ app: "falling-sands", type: "draw", s: strokes }).length;
}

// Remaining fraction, taking the min of area budget and memo budget
function budgetRemaining() {
  const areaRemaining = Math.max(0, 1 - usedBudget / maxBudget);
  const memoRemaining = Math.max(0, 1 - currentMemoLength() / MEMO_MAX_CHARS);
  return Math.min(areaRemaining, memoRemaining);
}

function budgetExhausted() {
  return usedBudget >= maxBudget || currentMemoLength() >= MEMO_MAX_CHARS;
}

// Would adding this segment exceed either budget?
function wouldExceedBudget(seg) {
  const area = segmentArea(seg);
  if (usedBudget + area > maxBudget) return true;
  // Estimate memo growth: one stroke adds ~"[x1,y1,x2,y2,size,species]," â‰ˆ 20-30 chars
  const estExtra = JSON.stringify([seg.x1, seg.y1, seg.x2, seg.y2, seg.size, seg.species]).length + 1;
  if (currentMemoLength() + estExtra > MEMO_MAX_CHARS) return true;
  return false;
}

function refreshBudget() {
  const remaining = budgetRemaining();
  budgetFill.style.width = (remaining * 100) + "%";
  // Color shifts from green â†’ yellow â†’ red as budget depletes
  if (remaining > 0.4) {
    budgetFill.style.background = "#5dd39e";
  } else if (remaining > 0.15) {
    budgetFill.style.background = "#f0c040";
  } else {
    budgetFill.style.background = "#ff6b6b";
  }
}

// â”€â”€ Simplify a run of nearly-collinear segments into fewer segments â”€â”€â”€â”€â”€
// Uses a greedy approach: extend the current merged segment as long as all
// intermediate points are within TOLERANCE pixels of the straight line
// between the merge start and the candidate endpoint.
const SIMPLIFY_TOLERANCE = 0.8;     // pixels â€” max perpendicular deviation

function perpendicularDist(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const lenSq = dx * dx + dy * dy;
  if (lenSq === 0) return Math.sqrt((px - ax) ** 2 + (py - ay) ** 2);
  return Math.abs(dy * px - dx * py + bx * ay - by * ax) / Math.sqrt(lenSq);
}

// Simplify segments from pendingStrokes[startIdx..endIdx) in-place.
// All segments in the range must share the same size & species and form a
// connected chain (seg[i].x2,y2 == seg[i+1].x1,y1).
function simplifyDragSegments(startIdx, endIdx) {
  if (endIdx - startIdx < 2) return;            // nothing to simplify

  const segs = pendingStrokes.slice(startIdx, endIdx);
  // Extract the polyline of points from the chain
  const pts = [{ x: segs[0].x1, y: segs[0].y1 }];
  for (const s of segs) pts.push({ x: s.x2, y: s.y2 });

  const size = segs[0].size;
  const species = segs[0].species;

  // Greedy merge: walk through pts, extending the current segment as far as
  // possible while all intermediate points stay within tolerance.
  const merged = [];
  let anchor = 0;
  while (anchor < pts.length - 1) {
    let farthest = anchor + 1;
    for (let cand = anchor + 2; cand < pts.length; cand++) {
      let ok = true;
      for (let mid = anchor + 1; mid < cand; mid++) {
        const d = perpendicularDist(
          pts[mid].x, pts[mid].y,
          pts[anchor].x, pts[anchor].y,
          pts[cand].x, pts[cand].y
        );
        if (d > SIMPLIFY_TOLERANCE) { ok = false; break; }
      }
      if (ok) farthest = cand; else break;
    }
    const seg = {
      x1: pts[anchor].x, y1: pts[anchor].y,
      x2: pts[farthest].x, y2: pts[farthest].y,
      size, species,
    };
    seg.area = segmentArea(seg);
    merged.push(seg);
    anchor = farthest;
  }

  // Splice the simplified segments back into pendingStrokes
  const removed = endIdx - startIdx;
  pendingStrokes.splice(startIdx, removed, ...merged);

  // Recalculate usedBudget from scratch (simplification changes areas)
  usedBudget = 0;
  for (const s of pendingStrokes) usedBudget += s.area || segmentArea(s);

  // Redraw overlay with the simplified strokes
  redrawOverlay();
  refreshFabs();
}

// â”€â”€ Draw a single line segment onto the overlay canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawOverlaySegment(seg) {
  const d = Math.max(seg.size * 2, 2);      // stroke width = brush diameter
  if (seg.species === 0) {
    // Eraser: dashed red line
    overlayCtx.strokeStyle = "rgba(255,100,100,0.7)";
    overlayCtx.lineWidth = d;
    overlayCtx.lineCap = "round";
    overlayCtx.setLineDash([3, 3]);
    overlayCtx.beginPath();
    overlayCtx.moveTo(seg.x1, seg.y1);
    overlayCtx.lineTo(seg.x2, seg.y2);
    overlayCtx.stroke();
    overlayCtx.setLineDash([]);
    return;
  }
  const sp = speciesById[seg.species];
  const color = sp ? sp.color : "#fff";

  // Filled stroke
  overlayCtx.strokeStyle = color;
  overlayCtx.lineWidth = d;
  overlayCtx.lineCap = "round";
  overlayCtx.globalAlpha = 0.55;
  overlayCtx.beginPath();
  overlayCtx.moveTo(seg.x1, seg.y1);
  overlayCtx.lineTo(seg.x2, seg.y2);
  overlayCtx.stroke();
  overlayCtx.globalAlpha = 1.0;

  // White border for visibility
  overlayCtx.strokeStyle = "rgba(255,255,255,0.45)";
  overlayCtx.lineWidth = d + 1.5;
  overlayCtx.lineCap = "round";
  overlayCtx.globalAlpha = 0.3;
  overlayCtx.beginPath();
  overlayCtx.moveTo(seg.x1, seg.y1);
  overlayCtx.lineTo(seg.x2, seg.y2);
  overlayCtx.stroke();
  overlayCtx.globalAlpha = 1.0;
}

// â”€â”€ Redraw the entire overlay from the pending strokes list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// (replaces the forward-declared stub from CANVAS SETUP)
redrawOverlay = function() {
  overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  for (const s of pendingStrokes) {
    drawOverlaySegment(s);
  }
};

// â”€â”€ Update the FAB bar visibility + budget meter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function refreshFabs() {
  if (pendingStrokes.length > 0) {
    fabBar.classList.add("visible");
  } else {
    fabBar.classList.remove("visible");
  }
  refreshBudget();
}

// â”€â”€ Convert event coords to simulation coords â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function eventToSim(e) {
  const rect = overlayCanvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) / rect.width * WIDTH);
  const y = Math.floor((e.clientY - rect.top) / rect.height * HEIGHT);
  if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return null;
  return { x, y };
}

// â”€â”€ Record a local paint segment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let liveSimplifyTimer = null;

function liveSimplify() {
  liveSimplifyTimer = null;
  if (!painting) return;
  const n = pendingStrokes.length;
  if (n - dragStartIdx < 4) return;             // not enough to bother
  simplifyDragSegments(dragStartIdx, n);
}

function localPaint(e) {
  if (budgetExhausted()) return;                // budget exhausted
  const pos = eventToSim(e);
  if (!pos) return;
  const from = lastPaintPos || pos;
  const seg = { x1: from.x, y1: from.y, x2: pos.x, y2: pos.y,
                size: brushSize, species: selectedSpecies };
  if (wouldExceedBudget(seg)) return;           // would exceed budget
  const area = segmentArea(seg);
  seg.area = area;
  usedBudget += area;
  pendingStrokes.push(seg);
  drawOverlaySegment(seg);
  lastPaintPos = pos;
  refreshFabs();

  // Schedule live simplification (throttled to every 120ms during drag)
  if (!liveSimplifyTimer) {
    liveSimplifyTimer = setTimeout(liveSimplify, 120);
  }
}

// â”€â”€ Sending state (spinner + disable UI) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let sending = false;
const sendSpinner = document.getElementById("send-spinner");

function setSending(v) {
  sending = !!v;
  btnSend.style.display = v ? "none" : "";
  btnDiscard.style.display = v ? "none" : "";
  sendSpinner.classList.toggle("hide", !v);
  // Keep the fab bar visible while the spinner is showing
  if (v) fabBar.classList.add("visible");
  // Disable drawing during send
  overlayCanvas.style.pointerEvents = v ? "none" : "auto";
}

// â”€â”€ Send all pending strokes as a transaction via usernode-bridge â”€â”€â”€â”€â”€â”€â”€â”€
btnSend.addEventListener("click", async () => {
  if (sending || !pendingStrokes.length) return;

  try {
    setSending(true);

    // Convert strokes to compact array format: [x1, y1, x2, y2, size, species]
    const strokes = pendingStrokes.map(s =>
      [s.x1, s.y1, s.x2, s.y2, s.size, s.species]
    );

    const memo = JSON.stringify({
      app: "falling-sands",
      type: "draw",
      s: strokes,
    });

    await sendTransaction(APP_PUBKEY, 1, memo, TX_SEND_OPTS);

    // Success â€” clear the overlay
    pendingStrokes = [];
    usedBudget = 0;
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    refreshFabs();
  } catch (e) {
    console.error("sendTransaction error:", e);
    statusEl.className = "err";
    statusEl.textContent = "Send failed: " + (e.message || e);
    // Don't clear strokes on error â€” user can retry
  } finally {
    setSending(false);
  }
});

// â”€â”€ Discard all pending strokes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
btnDiscard.addEventListener("click", () => {
  pendingStrokes = [];
  usedBudget = 0;
  overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  refreshFabs();
});

// â”€â”€ Pointer events on the overlay canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startPaint(e) {
  painting = true;
  lastPaintPos = null;               // new stroke â€” no previous point
  dragStartIdx = pendingStrokes.length;   // mark where this drag's segments begin
  localPaint(e);
}
function movePaint(e) {
  if (painting) localPaint(e);
}
function endPaint() {
  if (painting) {
    if (liveSimplifyTimer) { clearTimeout(liveSimplifyTimer); liveSimplifyTimer = null; }
    // Final simplify pass on this drag
    simplifyDragSegments(dragStartIdx, pendingStrokes.length);
  }
  painting = false;
  lastPaintPos = null;
}

overlayCanvas.addEventListener("mousedown", startPaint);
overlayCanvas.addEventListener("mousemove", movePaint);
window.addEventListener("mouseup", endPaint);

// Touch support
overlayCanvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  for (const touch of e.touches) startPaint(touch);
}, { passive: false });
overlayCanvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if (painting) for (const touch of e.touches) movePaint(touch);
}, { passive: false });
window.addEventListener("touchend", endPaint);
</script>
</body>
</html>

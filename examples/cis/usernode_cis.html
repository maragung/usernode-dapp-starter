<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <title>Usernode Collective Intelligence Service</title>
    <!-- Provides `getNodeAddress()`, `sendTransaction()`, and `getTransactions()` in both
         native (Flutter WebView) and local-dev (browser) modes. -->
    <script src="/usernode-bridge.js"></script>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0b0f16;
        --fg: #e7edf7;
        --muted: #a8b3c7;
        --card: #141b26;
        --border: rgba(255, 255, 255, 0.12);
        --accent: #6ea8fe;
        --danger: #ff6b6b;
        --ok: #5dd39e;
      }
      @media (prefers-color-scheme: light) {
        :root {
          --bg: #f7f8fb;
          --fg: #0b1220;
          --muted: #4b5568;
          --card: #ffffff;
          --border: rgba(15, 23, 42, 0.12);
          --accent: #2563eb;
          --danger: #c81e1e;
          --ok: #0f766e;
        }
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        background: var(--bg);
        color: var(--fg);
        height: 100vh;
        height: 100dvh;
      }

      main {
        height: 100vh;
        height: 100dvh;
        display: flex;
        justify-content: flex-start;
        align-items: stretch;
        padding: 16px;
        box-sizing: border-box;
      }

      .shell {
        width: 100%;
        max-width: 900px;
        margin: 0 auto;
        display: block;
      }

      .appCard {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 0;
        display: flex;
        flex-direction: column;
        height: 100%;
        min-height: 0;
        overflow: hidden;
      }

      .header {
        flex: 0 0 auto;
        padding: 16px;
        border-bottom: 1px solid var(--border);
        position: relative;
        z-index: 2;
        background: var(--card);
      }

      .content {
        flex: 1 1 auto;
        min-height: 0;
        overflow-y: auto;
        touch-action: pan-y;
        padding: 14px;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        gap: 14px;
        will-change: transform;
        position: relative;
        z-index: 1;
      }
      .archivedDock {
        margin-top: auto;
      }

      .panel {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 16px;
      }

      h1 {
        font-size: 18px;
        margin: 0 0 4px;
        letter-spacing: 0.2px;
      }
      p {
        margin: 8px 0;
        color: var(--muted);
        line-height: 1.45;
      }
      code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.95em;
      }

      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        color: var(--muted);
      }
      .pillButton {
        background: transparent;
        cursor: pointer;
      }
      .pillButton:hover {
        border-color: var(--accent);
      }
      .pillButton[disabled] {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .btn {
        appearance: none;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        background: transparent;
        color: var(--fg);
        cursor: pointer;
        text-align: left;
      }
      .btn:hover {
        border-color: var(--accent);
      }
      .btn[disabled] {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .btn.primary {
        background: color-mix(in oklab, var(--accent) 18%, transparent);
        border-color: color-mix(in oklab, var(--accent) 50%, var(--border));
      }
      .btn.selected {
        border-color: var(--accent);
        box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent) 18%, transparent);
        background: color-mix(in oklab, var(--accent) 10%, transparent);
      }

      .input {
        width: 100%;
        box-sizing: border-box;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--fg);
        font-size: 16px;
        outline: none;
      }
      .input:focus {
        border-color: var(--accent);
      }
      .inputAffix {
        display: flex;
        align-items: center;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: transparent;
      }
      .inputAffix:focus-within {
        border-color: var(--accent);
      }
      .inputAffixField {
        flex: 1 1 auto;
        min-width: 0;
        box-sizing: border-box;
        padding: 10px 12px;
        border: 0;
        outline: 0;
        background: transparent;
        color: var(--fg);
        font-size: 16px;
      }
      .inputAffixSuffix {
        padding: 0 12px 0 0;
        color: var(--muted);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        white-space: nowrap;
      }

      .grid2 {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      @media (min-width: 820px) {
        .grid2 {
          grid-template-columns: 1fr 1fr;
          align-items: start;
        }
      }

      .bar {
        height: 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        overflow: hidden;
        background: transparent;
      }
      .bar > div {
        height: 100%;
        background: var(--accent);
        width: 0%;
      }

      .loadingRow {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: var(--muted);
        font-size: 13px;
      }

      .tx-progress {
        width: 100%;
        margin: 10px 0 4px;
      }
      .tx-progress .tx-progress-track {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: var(--border);
        overflow: hidden;
      }
      .tx-progress .tx-progress-fill {
        height: 100%;
        width: 0%;
        border-radius: 3px;
        background: var(--accent);
        transition: width 0.4s ease-out, background-color 0.4s ease;
      }
      .tx-progress .tx-progress-fill.ok    { background: #6ef0a8; }
      .tx-progress .tx-progress-fill.warn  { background: #e6a817; }
      .tx-progress .tx-progress-fill.err   { background: var(--danger); }
      .tx-progress .tx-progress-label {
        font-size: 12px;
        color: var(--muted);
        margin-top: 4px;
        min-height: 16px;
      }
      .tx-progress .tx-progress-label.warn { color: #e6a817; }
      .tx-progress .tx-progress-label.err  { color: var(--danger); }

      .muted {
        color: var(--muted);
      }
      .danger {
        color: var(--danger);
      }
      .ok {
        color: var(--ok);
      }

      .hide {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <main>
      <div class="shell">
        <div class="appCard">
          <div class="header row" style="justify-content: space-between; align-items: flex-start;">
            <h1 style="margin: 0;">Usernode Collective Intelligence Service</h1>
            <div class="row">
              <button class="pill pillButton" id="headerUsernameBtn" type="button">
                User: <code id="headerUsername">(loading...)</code>
              </button>
              <button class="btn" id="backBtn" style="display: none;">Back</button>
            </div>
          </div>

          <div class="content" id="cisScrollRoot">
            <div class="panel hide" id="setUsernamePanel">
              <h3 style="margin: 0 0 8px; font-size: 14px;">Set username</h3>
              <label style="display: grid; gap: 6px; margin-top: 8px;">
                <span class="muted" style="font-size: 13px;">Username</span>
                <div class="inputAffix">
                  <input
                    id="usernameInput"
                    class="inputAffixField"
                    maxlength="24"
                    placeholder="username"
                  />
                  <span id="usernameSuffix" class="inputAffixSuffix">_unknown</span>
                </div>
              </label>
              <div class="row" style="margin-top: 10px;">
                <button class="btn primary" id="saveUsernameBtn" type="button">Save username</button>
                <button class="btn" id="cancelUsernameBtn" type="button">Cancel</button>
              </div>
              <div
                id="setUsernamePending"
                class="tx-progress hide"
                role="status"
                aria-live="polite"
              >
                <div class="tx-progress-track"><div class="tx-progress-fill"></div></div>
                <div class="tx-progress-label">Setting username...</div>
              </div>
            </div>

            <!-- Screen 1: Active survey list -->
            <div class="panel" id="screenActiveList">
              <div class="row" style="justify-content: space-between; align-items: baseline;">
                <h2 style="margin: 0; font-size: 15px;">Active surveys</h2>
                <div class="row">
                  <button class="btn" id="addSurveyBtn" type="button">Add survey</button>
                </div>
              </div>
              <p style="margin: 2px 0 0;">Pick a survey to view results and vote.</p>

              <div class="panel hide" id="addSurveyPanel" style="margin-top: 10px;">
                <h3 style="margin: 0 0 8px; font-size: 14px;">Create survey</h3>
                <div id="surveyCooldownHint" class="muted hide" style="font-size: 12px; margin-bottom: 8px;"></div>
                <div class="muted" style="font-size: 12px; margin-bottom: 8px;">You can create up to 3 surveys every 24 hours.</div>
                <label style="display: grid; gap: 6px; margin-top: 8px;">
                  <span class="muted" style="font-size: 13px;">Title</span>
                  <input id="newSurveyTitle" class="input" maxlength="80" />
                </label>
                <label style="display: grid; gap: 6px; margin-top: 8px;">
                  <span class="muted" style="font-size: 13px;">Question</span>
                  <input id="newSurveyQuestion" class="input" maxlength="160" />
                </label>
                <div style="display: grid; gap: 6px; margin-top: 8px;">
                  <span class="muted" style="font-size: 13px;">Options</span>
                  <div id="surveyOptionsList" style="display: grid; gap: 6px;"></div>
                  <button class="btn" id="addSurveyOptionBtn" type="button" style="justify-self: start; font-size: 12px;">+ Add option</button>
                </div>
                <label style="display: grid; gap: 6px; margin-top: 8px;">
                  <span class="muted" style="font-size: 13px;">Active for</span>
                  <select id="newSurveyDuration" class="input">
                    <option value="172800000">2 days</option>
                    <option value="259200000">3 days</option>
                    <option value="345600000">4 days</option>
                    <option value="432000000">5 days</option>
                    <option value="518400000">6 days</option>
                    <option value="604800000" selected>7 days</option>
                    <option value="60000">1 minute (testing)</option>
                  </select>
                </label>
                <div class="row" style="margin-top: 10px;">
                  <button class="btn primary" id="saveSurveyBtn" type="button">Save survey</button>
                  <button class="btn" id="cancelSurveyBtn" type="button">Cancel</button>
                </div>
                <div
                  id="addSurveyPending"
                  class="tx-progress hide"
                  role="status"
                  aria-live="polite"
                >
                  <div class="tx-progress-track"><div class="tx-progress-fill"></div></div>
                  <div class="tx-progress-label">Creating survey...</div>
                </div>
              </div>

              <div id="activeSurveyList" style="display: grid; gap: 10px; margin-top: 8px;"></div>
            </div>

            <div class="panel archivedDock hide" id="screenArchivedList">
              <h3 style="margin: 0 0 8px; font-size: 14px;">Archived surveys</h3>
              <div id="archivedSurveyList" style="display: grid; gap: 10px;"></div>
            </div>

            <!-- Screen 2: Survey detail -->
            <div class="panel hide" id="screenSurvey">
              <div class="row" style="justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; font-size: 15px;" id="surveyTitle">(survey)</h2>
                <div class="row" style="gap: 8px; align-items: center;">
                  <span id="surveyCountdown" class="muted" style="font-size: 12px; font-variant-numeric: tabular-nums;"></span>
                  <button class="btn" id="addOptionToggleBtn" type="button">Add option</button>
                </div>
              </div>
              <p style="margin-top: 0;" id="surveyQuestion"></p>
              <div id="surveyCreatedBy" class="muted" style="font-size: 11px; margin: 6px 0;"></div>
              <div id="votePending" class="tx-progress hide" role="status" aria-live="polite">
                <div class="tx-progress-track"><div class="tx-progress-fill"></div></div>
                <div class="tx-progress-label">Registering vote...</div>
              </div>

              <div style="margin-top: 10px; display: grid; gap: 8px;">
                <div class="hide" id="addOptionPanel">
                  <div class="muted" style="font-size: 13px; margin-bottom: 8px;">
                    You can add up to one custom option for this survey.
                  </div>
                  <div
                    id="addOptionHint"
                    class="muted"
                    style="font-size: 12px; margin-bottom: 8px;"
                  ></div>
                  <div class="row">
                    <input
                      id="newOptionInput"
                      class="input"
                      maxlength="80"
                      placeholder="Add your own option"
                      style="flex: 1 1 240px;"
                    />
                  </div>
                  <div class="row" style="margin-top: 8px;">
                    <button class="btn primary" id="saveOptionBtn" type="button">Save option</button>
                    <button class="btn" id="cancelOptionBtn" type="button">Cancel</button>
                  </div>
                </div>
              </div>

              <hr style="border: 0; border-top: 1px solid var(--border); margin: 16px 0;" />

              <h3 style="margin: 0 0 8px; font-size: 14px;">Results</h3>
              <div id="resultsBars" style="display: grid; gap: 12px; margin-top: 10px;"></div>
            </div>
          </div>
        </div>
      </div>
    </main>

    <script>
      (function () {
        // --- Minimal native promise bridge (compatible with usernode-bridge.js) ---
        window.__usernodeBridge = window.__usernodeBridge || { pending: {} };
        window.__usernodeResolve =
          window.__usernodeResolve ||
          function (id, value, error) {
            const entry = window.__usernodeBridge.pending[id];
            if (!entry) return;
            delete window.__usernodeBridge.pending[id];
            if (error) entry.reject(new Error(error));
            else entry.resolve(value);
          };

        function callNative(method, args) {
          const id = String(Date.now()) + "-" + Math.random().toString(16).slice(2);
          return new Promise((resolve, reject) => {
            window.__usernodeBridge.pending[id] = { resolve, reject };
            if (!window.Usernode || typeof window.Usernode.postMessage !== "function") {
              delete window.__usernodeBridge.pending[id];
              reject(
                new Error(
                  "Usernode native bridge not available (are you running inside the app WebView, or did you forget to include /usernode-bridge.js?)"
                )
              );
              return;
            }
            window.Usernode.postMessage(JSON.stringify({ method, id, args: args || {} }));
          });
        }

        async function getNodeAddress() {
          if (typeof window.getNodeAddress === "function") return await window.getNodeAddress();
          return await callNative("getNodeAddress");
        }

        async function sendTransaction(destination_pubkey, amount, memo, opts) {
          if (typeof window.sendTransaction === "function") {
            return await window.sendTransaction(destination_pubkey, amount, memo, opts);
          }
          return await callNative("sendTransaction", { destination_pubkey, amount, memo });
        }

        // --- CIS configuration ---
        // You can override at runtime via:
        //   localStorage.setItem("cis:app_pubkey", "ut1...")
        // (we also accept the old exocortex keys for backward compatibility)
        const CIS_APP_PUBKEY =
          (window.CIS_APP_PUBKEY && String(window.CIS_APP_PUBKEY)) ||
          window.localStorage.getItem("cis:app_pubkey") ||
          window.localStorage.getItem("exocortex:app_pubkey") ||
          "ut1zkj9p90e0w0hqsnmr70xmzdcvhrj80upajpw67eywszu2g0qknksl3mlms";

        // Explorer proxy (server.js forwards /explorer-api/* to the block explorer)
        const EXPLORER_BASE = window.location.origin + "/explorer-api";
        let chainId = null;

        async function explorerFetch(path, opts) {
          const url = `${EXPLORER_BASE}${path}`;
          const resp = await fetch(url, opts);
          if (!resp.ok) {
            const text = await resp.text().catch(() => "");
            throw new Error(`Explorer API ${resp.status}: ${text}`);
          }
          return await resp.json();
        }

        async function discoverChainId() {
          const data = await explorerFetch("/active_chain");
          return data.chain_id;
        }

        async function queryTransactions(body) {
          if (!chainId) return { items: [] };
          return await explorerFetch(`/${chainId}/transactions`, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify(body || {}),
          });
        }

        // Surveys: rebuilt from on-chain transactions each refresh cycle.
        let SURVEYS = [];
        let GLOBAL_USERNAMES = new Map(); // address -> username

        function last6(s) {
          const v = String(s || "");
          return v.length >= 6 ? v.slice(-6) : v;
        }

        function usernameSuffix(address) {
          const core = last6(address);
          return core ? `_${core}` : "_unknown";
        }

        function normalizeUsername(raw, fallback, addressForSuffix) {
          const suffix = usernameSuffix(addressForSuffix);
          const maxBaseLen = Math.max(1, 24 - suffix.length);
          const fallbackValue = (() => {
            const f = String(fallback || "").trim();
            if (!f) return `user${suffix}`;
            if (f.endsWith(suffix)) return f.slice(0, maxBaseLen) + suffix;
            const stripped = f.replace(/_[A-Za-z0-9]{6}$/, "").slice(0, maxBaseLen);
            return (stripped || "user") + suffix;
          })();

          let v = String(raw || "").trim();
          if (!v) return fallbackValue;
          v = v.replace(/[^\w-]/g, "");
          if (!v) return fallbackValue;
          if (v.endsWith(suffix)) {
            const base = v.slice(0, -suffix.length).slice(0, maxBaseLen);
            return (base || "user") + suffix;
          }

          // If a user pasted another username shape, drop any old suffix-like tail.
          v = v.replace(/_[A-Za-z0-9]{6}$/, "");
          const base = v.slice(0, maxBaseLen);
          return (base || "user") + suffix;
        }

        function makeMemo(obj) {
          // Keep it short and parseable.
          return JSON.stringify(obj);
        }

        function slugify(s) {
          return String(s || "")
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "_")
            .replace(/^_+|_+$/g, "")
            .slice(0, 40);
        }

        const ALLOWED_SURVEY_DURATION_MS = new Set([
          60_000,
          2 * 24 * 60 * 60 * 1000,
          3 * 24 * 60 * 60 * 1000,
          4 * 24 * 60 * 60 * 1000,
          5 * 24 * 60 * 60 * 1000,
          6 * 24 * 60 * 60 * 1000,
          7 * 24 * 60 * 60 * 1000,
        ]);
        const DEFAULT_SURVEY_DURATION_MS = 7 * 24 * 60 * 60 * 1000;

        function normalizeSurveyDurationMs(v) {
          const n = typeof v === "number" ? Math.round(v) : Number(v);
          if (!Number.isFinite(n)) return DEFAULT_SURVEY_DURATION_MS;
          return ALLOWED_SURVEY_DURATION_MS.has(n) ? n : DEFAULT_SURVEY_DURATION_MS;
        }

        function normalizeSurveyDefinition(rawSurvey) {
          if (!rawSurvey || typeof rawSurvey !== "object") return null;
          const title = String(rawSurvey.title || "").trim();
          const question = String(rawSurvey.question || "").trim();
          const activeDurationMs = normalizeSurveyDurationMs(
            rawSurvey.active_duration_ms != null
              ? rawSurvey.active_duration_ms
              : rawSurvey.duration_ms
          );
          const optionsRaw = Array.isArray(rawSurvey.options) ? rawSurvey.options : [];
          const options = optionsRaw
            .map((o, i) => {
              if (!o || typeof o !== "object") return null;
              const label = String(o.label || "").trim();
              if (!label) return null;
              const key = String(o.key || slugify(label) || `opt_${i + 1}`);
              return { key, label };
            })
            .filter(Boolean);
          if (!title || !question) return null;
          const idBase = String(rawSurvey.id || slugify(title) || "").trim();
          if (!idBase) return null;
          return {
            id: idBase,
            title,
            question,
            activeDurationMs,
            options,
            builtIn: false,
          };
        }

        function rebuildSurveysFromTransactions(txs) {
          // Build global username map from set_username txs (latest per sender wins).
          const nameMap = new Map();
          for (const rawTx of txs) {
            const p = parseCisTx(rawTx);
            if (!p || p.memo.type !== "set_username") continue;
            const prev = nameMap.get(p.tx.from);
            if (!prev || p.tx.ts >= prev.ts) {
              const u = normalizeUsername(p.memo.username, deriveDefaultUsername(p.tx.from), p.tx.from);
              nameMap.set(p.tx.from, { name: u, ts: p.tx.ts });
            }
          }
          GLOBAL_USERNAMES = new Map();
          for (const [addr, v] of nameMap) GLOBAL_USERNAMES.set(addr, v.name);

          // Collect all valid create_survey txs with sender + timestamp.
          const allCreations = []; // { survey, ts, from }
          for (const rawTx of txs) {
            const parsed = parseCisTx(rawTx);
            if (!parsed || parsed.memo.type !== "create_survey") continue;
            const survey = normalizeSurveyDefinition(parsed.memo.survey);
            if (!survey) continue;
            allCreations.push({ survey, ts: parsed.tx.ts, from: parsed.tx.from });
          }

          // Sort oldest-first so we enforce the rolling window chronologically.
          allCreations.sort((a, b) => a.ts - b.ts);

          // Per-sender: only accept a survey if the sender hasn't created
          // MAX_SURVEYS_PER_WINDOW in the previous 24 hours.
          const creationsBySender = new Map(); // sender -> [ts, ...]
          const latestCreated = new Map(); // surveyId -> { survey, ts }
          for (const entry of allCreations) {
            const times = creationsBySender.get(entry.from) || [];
            const windowStart = entry.ts - SURVEY_COOLDOWN_MS;
            const recent = times.filter(t => t > windowStart);
            if (recent.length >= MAX_SURVEYS_PER_WINDOW) continue;
            recent.push(entry.ts);
            creationsBySender.set(entry.from, recent);
            const existing = latestCreated.get(entry.survey.id);
            if (!existing || entry.ts >= existing.ts) {
              latestCreated.set(entry.survey.id, { survey: entry.survey, ts: entry.ts, from: entry.from });
            }
          }

          // Order by most recent creation first.
          const now = Date.now();
          SURVEYS = Array.from(latestCreated.values())
            .sort((a, b) => b.ts - a.ts)
            .map((x) => {
              const expiresAtMs = x.ts + x.survey.activeDurationMs;
              return {
                ...x.survey,
                createdBy: x.from,
                createdAtMs: x.ts,
                expiresAtMs,
                archived: now >= expiresAtMs,
              };
            });
        }

        function parseMemo(m) {
          if (m == null) return null;
          const s = String(m);
          try {
            return JSON.parse(s);
          } catch (_) {
            return null;
          }
        }

        function extractTxTimestampMs(tx) {
          if (!tx || typeof tx !== "object") return null;
          const candidates = [
            tx.created_at,
            tx.createdAt,
            tx.timestamp_ms,
            tx.timestampMs,
            tx.timestamp,
            tx.time,
          ];
          for (const v of candidates) {
            if (typeof v === "number" && Number.isFinite(v)) return v < 10_000_000_000 ? v * 1000 : v;
            if (typeof v === "string" && v.trim()) {
              const t = Date.parse(v);
              if (!Number.isNaN(t)) return t;
            }
          }
          return null;
        }

        function normalizeTransactionsResponse(resp) {
          if (Array.isArray(resp)) return resp;
          if (!resp || typeof resp !== "object") return [];
          if (Array.isArray(resp.items)) return resp.items;
          if (Array.isArray(resp.transactions)) return resp.transactions;
          if (resp.data && Array.isArray(resp.data.items)) return resp.data.items;
          return [];
        }

        function pick(obj, keys) {
          for (const k of keys) {
            if (obj && obj[k] != null) return obj[k];
          }
          return null;
        }

        function normalizeTx(tx) {
          if (!tx || typeof tx !== "object") return null;
          const from = pick(tx, ["from_pubkey", "from", "source", "fromAddress", "from_address"]);
          const to = pick(tx, ["destination_pubkey", "to", "destination", "toAddress", "to_address"]);
          const memo = pick(tx, ["memo"]);
          const amount = pick(tx, ["amount"]);
          const ts = extractTxTimestampMs(tx) || Date.now();
          const id = pick(tx, ["id", "txid", "tx_id", "hash"]);
          return {
            id: id == null ? null : String(id),
            from: from == null ? null : String(from),
            to: to == null ? null : String(to),
            amount: amount == null ? null : amount,
            memo: memo == null ? null : String(memo),
            ts,
            raw: tx,
          };
        }

        // Shared: normalize a raw tx and parse its CIS memo in one step.
        // Returns { tx, memo } or null if it's not a valid CIS transaction.
        function parseCisTx(rawTx) {
          const tx = normalizeTx(rawTx);
          if (!tx || !tx.from || !tx.to || tx.to !== CIS_APP_PUBKEY) return null;
          const memoObj = parseMemo(tx.memo);
          if (!memoObj) return null;
          const app = memoObj.app ? String(memoObj.app) : null;
          if (app !== "cis" && app !== "exocortex") return null;
          return { tx, memo: memoObj };
        }

        const TX_SEND_OPTS = { timeoutMs: 45_000, pollIntervalMs: 800 };

        async function getCisTransactions(limit) {
          const l = typeof limit === "number" ? limit : 200;

          // Explorer proxy API (real chain data).
          if (chainId) {
            try {
              const data = await queryTransactions({
                recipient: CIS_APP_PUBKEY,
                limit: l,
              });
              return normalizeTransactionsResponse(data);
            } catch (e) {
              console.warn("Explorer getCisTransactions failed:", e);
            }
          }

          // Local-dev mock server (usernode-dapp-starter) supports this endpoint.
          try {
            const r = await fetch("/__mock/getTransactions", {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify({
                owner_pubkey: CIS_APP_PUBKEY,
                filterOptions: { limit: l },
              }),
            });
            if (r.ok) {
              const json = await r.json();
              return normalizeTransactionsResponse(json);
            }
          } catch (_) {}

          // If a generic getTransactions exists (remote API), try it as a last resort.
          if (typeof window.getTransactions === "function") {
            const resp = await window.getTransactions({ limit: l, account: CIS_APP_PUBKEY });
            return normalizeTransactionsResponse(resp);
          }

          throw new Error("No getTransactions() source available");
        }

        // --- UI wiring ---
        const $ = (id) => document.getElementById(id);
        const backBtn = $("backBtn");
        const headerUsernameBtn = $("headerUsernameBtn");

        const screenActiveList = $("screenActiveList");
        const screenArchivedList = $("screenArchivedList");
        const setUsernamePanel = $("setUsernamePanel");
        const setUsernamePendingEl = $("setUsernamePending");
        const usernameInputEl = $("usernameInput");
        const usernameSuffixEl = $("usernameSuffix");
        const saveUsernameBtn = $("saveUsernameBtn");
        const cancelUsernameBtn = $("cancelUsernameBtn");
        const addSurveyBtn = $("addSurveyBtn");
        const addSurveyPanel = $("addSurveyPanel");
        const addSurveyPendingEl = $("addSurveyPending");
        const surveyCooldownHintEl = $("surveyCooldownHint");
        const saveSurveyBtn = $("saveSurveyBtn");
        const cancelSurveyBtn = $("cancelSurveyBtn");
        const newSurveyTitleEl = $("newSurveyTitle");
        const newSurveyQuestionEl = $("newSurveyQuestion");
        const surveyOptionsListEl = $("surveyOptionsList");
        const addSurveyOptionBtn = $("addSurveyOptionBtn");
        const newSurveyDurationEl = $("newSurveyDuration");
        const activeSurveyListEl = $("activeSurveyList");
        const archivedSurveyListEl = $("archivedSurveyList");
        const screenSurvey = $("screenSurvey");
        const surveyTitleEl = $("surveyTitle");
        const surveyQuestionEl = $("surveyQuestion");
        const surveyCreatedByEl = $("surveyCreatedBy");
        const votePendingEl = $("votePending");
        const addOptionToggleBtn = $("addOptionToggleBtn");
        const addOptionPanelEl = $("addOptionPanel");
        const newOptionInputEl = $("newOptionInput");
        const saveOptionBtn = $("saveOptionBtn");
        const cancelOptionBtn = $("cancelOptionBtn");
        const addOptionHintEl = $("addOptionHint");
        const resultsBarsEl = $("resultsBars");
        const surveyCountdownEl = $("surveyCountdown");
        const headerUsernameEl = $("headerUsername");

        let currentSurveyId = null;
        let latestTxs = [];
        function currentSurvey() {
          return SURVEYS.find((s) => s.id === currentSurveyId) || null;
        }

        function setText(el, v) {
          if (!el) return;
          el.textContent = v;
        }

        function formatArchivedDate(expiresAtMs) {
          if (!expiresAtMs) return "Archived";
          const d = new Date(expiresAtMs);
          const mon = d.toLocaleString(undefined, { month: "short" });
          const day = d.getDate();
          const year = d.getFullYear();
          const now = new Date();
          if (year === now.getFullYear()) return `Archived ${mon} ${day}`;
          return `Archived ${mon} ${day}, ${year}`;
        }

        function formatCountdown(expiresAtMs) {
          const diff = Math.max(0, expiresAtMs - Date.now());
          if (diff <= 0) return "Completed";
          const pad = (n) => String(n).padStart(2, "0");
          if (diff < 3600000) {
            // Less than 1 hour: show mm:ss
            const totalSec = Math.floor(diff / 1000);
            const mm = Math.floor(totalSec / 60);
            const ss = totalSec % 60;
            return `${pad(mm)}:${pad(ss)}`;
          }
          const totalMin = Math.floor(diff / 60000);
          const dd = Math.floor(totalMin / 1440);
          const hh = Math.floor((totalMin % 1440) / 60);
          const mm = totalMin % 60;
          return `${pad(dd)}d ${pad(hh)}h ${pad(mm)}m`;
        }

        // --- Rubber-band pull on top/bottom edges while preserving normal scroll ---
        const RUBBER_BAND = {
          deadzonePx: 6,
          maxPullPx: 92,
          constant: 0.56,
          snapMs: 210,
          snapEasing: "cubic-bezier(0.2, 0.9, 0.2, 1)",
          enableScaleY: true,
          scaleDivisor: 850,
        };

        function rubberBandDistance(d, dimension, constant) {
          const abs = Math.abs(d);
          if (dimension <= 0) return 0;
          const result = (constant * abs * dimension) / (dimension + constant * abs);
          return Math.sign(d) * result;
        }

        function attachRubberBand() {
          const scroller = document.getElementById("cisScrollRoot");
          if (!scroller) return;

          let startY = 0;
          let activePointerId = null;
          let dragging = false;

          function apply(offset) {
            if (RUBBER_BAND.enableScaleY) {
              const s = 1 + Math.abs(offset) / RUBBER_BAND.scaleDivisor;
              scroller.style.transform = `translateY(${offset}px) scaleY(${s})`;
            } else {
              scroller.style.transform = `translateY(${offset}px)`;
            }
          }

          function reset() {
            scroller.style.transition = `transform ${RUBBER_BAND.snapMs}ms ${RUBBER_BAND.snapEasing}`;
            scroller.style.transform = "";
            window.setTimeout(() => {
              scroller.style.transition = "";
            }, RUBBER_BAND.snapMs + 40);
          }

          scroller.addEventListener("pointerdown", (e) => {
            if (e.button != null && e.button !== 0) return;
            activePointerId = e.pointerId;
            startY = e.clientY;
            dragging = true;
            scroller.style.transition = "";
          });

          scroller.addEventListener(
            "pointermove",
            (e) => {
              if (!dragging || e.pointerId !== activePointerId) return;
              const dy = e.clientY - startY;
              const atTop = scroller.scrollTop <= 0;
              const atBottom =
                scroller.scrollTop + scroller.clientHeight >= scroller.scrollHeight - 1;
              const pullingPastTop = atTop && dy > 0;
              const pullingPastBottom = atBottom && dy < 0;

              if (!pullingPastTop && !pullingPastBottom) return;

              const effectiveDy =
                Math.abs(dy) <= RUBBER_BAND.deadzonePx
                  ? 0
                  : dy - Math.sign(dy) * RUBBER_BAND.deadzonePx;

              const dim = window.innerHeight || 800;
              let offset = rubberBandDistance(
                effectiveDy,
                dim,
                RUBBER_BAND.constant
              );
              const max = RUBBER_BAND.maxPullPx;
              if (offset > max) offset = max;
              if (offset < -max) offset = -max;

              apply(offset);
              e.preventDefault();
            },
            { passive: false }
          );

          function end(e) {
            if (!dragging || e.pointerId !== activePointerId) return;
            dragging = false;
            activePointerId = null;
            reset();
          }

          scroller.addEventListener("pointerup", end);
          scroller.addEventListener("pointercancel", end);
        }

        function setDisabled(el, v) {
          if (!el) return;
          el.disabled = !!v;
        }

        function show(el, on) {
          if (!el) return;
          el.classList.toggle("hide", !on);
        }

        let me = null;
        let myUsername = null;
        let sending = false;
        let latestVoteKey = null;
        let myAddedOptionBySurvey = {};
        let currentOptionByKey = new Map();

        function setUsernameUi(name) {
          const v = name == null ? "(not set)" : String(name);
          setText(headerUsernameEl, v);
        }

        function addSurveyOptionField(value) {
          if (!surveyOptionsListEl) return;
          const row = document.createElement("div");
          row.style.cssText = "display:flex;gap:6px;align-items:center;";
          const inp = document.createElement("input");
          inp.className = "input";
          inp.maxLength = 80;
          inp.placeholder = "Option " + (surveyOptionsListEl.children.length + 1);
          inp.value = value || "";
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "btn";
          removeBtn.style.cssText = "font-size:12px;padding:4px 8px;flex:0 0 auto;";
          removeBtn.textContent = "✕";
          removeBtn.addEventListener("click", () => {
            row.remove();
            reindexOptionPlaceholders();
          });
          row.appendChild(inp);
          row.appendChild(removeBtn);
          surveyOptionsListEl.appendChild(row);
        }

        function reindexOptionPlaceholders() {
          if (!surveyOptionsListEl) return;
          Array.from(surveyOptionsListEl.children).forEach((row, i) => {
            const inp = row.querySelector("input");
            if (inp) inp.placeholder = "Option " + (i + 1);
          });
        }

        function getSurveyOptionInputs() {
          if (!surveyOptionsListEl) return [];
          return Array.from(surveyOptionsListEl.querySelectorAll("input"));
        }

        function initSurveyOptionFields() {
          if (!surveyOptionsListEl) return;
          surveyOptionsListEl.innerHTML = "";
          addSurveyOptionField("");
          addSurveyOptionField("");
        }

        function clearAddSurveyForm() {
          if (newSurveyTitleEl) newSurveyTitleEl.value = "";
          if (newSurveyQuestionEl) newSurveyQuestionEl.value = "";
          initSurveyOptionFields();
          if (newSurveyDurationEl) newSurveyDurationEl.value = String(DEFAULT_SURVEY_DURATION_MS);
        }

        function clearUsernameForm() {
          if (usernameInputEl) {
            const suffix = usernameSuffix(me);
            const full = myUsername || deriveDefaultUsername(me);
            const base = String(full || "").endsWith(suffix)
              ? String(full).slice(0, -suffix.length)
              : String(full || "").replace(/_[A-Za-z0-9]{6}$/, "");
            usernameInputEl.value = base || "user";
          }
          setText(usernameSuffixEl, usernameSuffix(me));
        }

        function createSurveyFromForm() {
          const title = String(newSurveyTitleEl && newSurveyTitleEl.value || "").trim();
          const question = String(newSurveyQuestionEl && newSurveyQuestionEl.value || "").trim();
          const labels = getSurveyOptionInputs()
            .map((inp) => inp.value.trim())
            .filter(Boolean);
          const activeDurationMs = normalizeSurveyDurationMs(
            newSurveyDurationEl ? newSurveyDurationEl.value : DEFAULT_SURVEY_DURATION_MS
          );
          if (!title) throw new Error("Title is required");
          if (!question) throw new Error("Question is required");
          // Options are optional — users/bots can add options later.

          const options = labels.map((label, i) => ({
            key: slugify(label) || `opt_${i + 1}`,
            label,
          }));
          const idBase = slugify(title) || "survey";
          const id = `custom_${idBase}_${Date.now().toString(36)}`;
          return { id, title, question, options, activeDurationMs, builtIn: false };
        }

        function setSelectedVote(keyOrNull) {
          const k = keyOrNull || null;
          if (!resultsBarsEl) return;
          const btns = resultsBarsEl.querySelectorAll("button[data-choice]");
          btns.forEach((b) => {
            const choice = b.getAttribute("data-choice");
            b.classList.toggle("selected", choice === k);
          });
        }

        // --- Transaction progress bar controller ---
        const TX_PROGRESS_EXPECTED_S = 30;
        const TX_PROGRESS_WARN_S    = 45;
        const TX_PROGRESS_ERR_S     = 90;

        let _txProgressRaf = null;
        let _txProgressStart = 0;

        function txProgressPercent(elapsedS) {
          if (elapsedS <= TX_PROGRESS_EXPECTED_S) {
            const t = elapsedS / TX_PROGRESS_EXPECTED_S;
            return 95 * (1 - Math.pow(1 - t, 3));
          }
          return 95 + 5 * (1 - Math.exp(-(elapsedS - TX_PROGRESS_EXPECTED_S) / 120));
        }

        function txProgressAllBars() {
          return [setUsernamePendingEl, addSurveyPendingEl, votePendingEl].filter(
            (el) => el && !el.classList.contains("hide")
          );
        }

        function txProgressApply(bars, pct, elapsedS) {
          let fillCls = "";
          let labelCls = "";
          let labelExtra = "";
          if (elapsedS >= TX_PROGRESS_ERR_S) {
            fillCls = "err";
            labelCls = "err";
            labelExtra = "Transaction is taking longer than it should; please check Discord for more information";
          } else if (elapsedS >= TX_PROGRESS_WARN_S) {
            fillCls = "warn";
            labelCls = "warn";
            labelExtra = "Transaction is taking longer than expected";
          }
          bars.forEach((container) => {
            const fill = container.querySelector(".tx-progress-fill");
            const label = container.querySelector(".tx-progress-label");
            if (fill) {
              fill.style.width = pct + "%";
              fill.className = "tx-progress-fill" + (fillCls ? " " + fillCls : "");
            }
            if (label && labelExtra) {
              label.textContent = labelExtra;
              label.className = "tx-progress-label" + (labelCls ? " " + labelCls : "");
            }
          });
        }

        function startTxProgress() {
          stopTxProgress();
          _txProgressStart = performance.now();
          function tick() {
            const elapsedS = (performance.now() - _txProgressStart) / 1000;
            const pct = txProgressPercent(elapsedS);
            const bars = txProgressAllBars();
            txProgressApply(bars, pct, elapsedS);
            _txProgressRaf = requestAnimationFrame(tick);
          }
          _txProgressRaf = requestAnimationFrame(tick);
        }

        function completeTxProgress() {
          if (_txProgressRaf) {
            cancelAnimationFrame(_txProgressRaf);
            _txProgressRaf = null;
          }
          const bars = txProgressAllBars();
          bars.forEach((container) => {
            const fill = container.querySelector(".tx-progress-fill");
            const label = container.querySelector(".tx-progress-label");
            if (fill) {
              fill.className = "tx-progress-fill ok";
              fill.style.width = "100%";
            }
            if (label) {
              label.textContent = "Confirmed!";
              label.className = "tx-progress-label";
            }
          });
          setTimeout(() => {
            bars.forEach((c) => c.classList.add("hide"));
            resetTxProgressBars(bars);
          }, 1200);
        }

        function stopTxProgress() {
          if (_txProgressRaf) {
            cancelAnimationFrame(_txProgressRaf);
            _txProgressRaf = null;
          }
        }

        function resetTxProgressBars(bars) {
          (bars || [setUsernamePendingEl, addSurveyPendingEl, votePendingEl]).forEach((container) => {
            if (!container) return;
            const fill = container.querySelector(".tx-progress-fill");
            const label = container.querySelector(".tx-progress-label");
            if (fill) {
              fill.style.width = "0%";
              fill.className = "tx-progress-fill";
            }
            if (label) {
              label.className = "tx-progress-label";
            }
          });
        }

        function setSending(v) {
          sending = !!v;
          if (sending) {
            show(votePendingEl, true);
            show(addSurveyPendingEl, !currentSurveyId);
            show(setUsernamePendingEl, !currentSurveyId);
            resetTxProgressBars();
            const bars = txProgressAllBars();
            bars.forEach((container) => {
              const label = container.querySelector(".tx-progress-label");
              if (label) {
                if (container === votePendingEl) label.textContent = "Registering vote...";
                else if (container === addSurveyPendingEl) label.textContent = "Creating survey...";
                else if (container === setUsernamePendingEl) label.textContent = "Setting username...";
              }
            });
            startTxProgress();
          } else {
            completeTxProgress();
          }
          setDisabled(headerUsernameBtn, sending);
          setDisabled(saveUsernameBtn, sending);
          setDisabled(cancelUsernameBtn, sending);
          setDisabled(usernameInputEl, sending);
          setDisabled(addSurveyBtn, sending);
          setDisabled(saveSurveyBtn, sending);
          setDisabled(cancelSurveyBtn, sending);
          setDisabled(newSurveyTitleEl, sending);
          setDisabled(newSurveyQuestionEl, sending);
          getSurveyOptionInputs().forEach((inp) => setDisabled(inp, sending));
          setDisabled(addSurveyOptionBtn, sending);
          setDisabled(newSurveyDurationEl, sending);
          if (resultsBarsEl) {
            const btns = resultsBarsEl.querySelectorAll("button");
            btns.forEach((b) => setDisabled(b, sending));
          }
          setDisabled(addOptionToggleBtn, sending);
          setDisabled(saveOptionBtn, sending);
          setDisabled(cancelOptionBtn, sending);
          setDisabled(newOptionInputEl, sending);
        }

        function deriveDefaultUsername(address) {
          return `user${usernameSuffix(address)}`;
        }

        async function voteFlow(optionKey, optionLabelHint) {
          const s = currentSurvey();
          if (!s) throw new Error("No survey selected");
          if (s.archived) throw new Error("Archived surveys are read-only");
          const fromCurrent = s.options.find((o) => o.key === optionKey) || null;
          const fromRendered = currentOptionByKey.get(optionKey) || null;
          const opt =
            fromCurrent ||
            fromRendered ||
            {
              key: optionKey,
              label: optionLabelHint || String(optionKey),
            };
          setSending(true);
          const memo = makeMemo({
            app: "cis",
            type: "vote",
            survey: s.id,
            choice: opt.key,
          });
          await sendTransaction(CIS_APP_PUBKEY, 1, memo, TX_SEND_OPTS);
          // Keep vote highlight and counts synchronized by updating both from the
          // same transaction snapshot in refreshLoopOnce().
          await refreshLoopOnce();
        }

        async function addOptionFlow(labelRaw) {
          const s = currentSurvey();
          if (!s) throw new Error("No survey selected");
          if (s.archived) throw new Error("Archived surveys are read-only");
          const label = String(labelRaw || "").trim();
          if (!label) throw new Error("Option text is required");
          if (myAddedOptionBySurvey[s.id]) {
            throw new Error("You can only add one option per survey");
          }
          const optionKey = slugify(label) || `opt_${Date.now().toString(36)}`;
          const memo = makeMemo({
            app: "cis",
            type: "add_option",
            survey: s.id,
            option: { key: optionKey, label },
          });
          await sendTransaction(CIS_APP_PUBKEY, 1, memo, TX_SEND_OPTS);
          await refreshLoopOnce();
        }

        async function setUsernameFlow(raw) {
          const value = normalizeUsername(raw, deriveDefaultUsername(me), me);
          if (!value) throw new Error("Username is required");
          const memo = makeMemo({
            app: "cis",
            type: "set_username",
            username: value,
          });
          await sendTransaction(CIS_APP_PUBKEY, 1, memo, TX_SEND_OPTS);
          myUsername = value;
          setUsernameUi(myUsername);
          await refreshLoopOnce();
        }

        function getMyLatestUsername(txs, address) {
          if (!address) return null;
          const meAddr = String(address);
          let latest = null;
          let latestTs = -1;
          for (const rawTx of txs) {
            const parsed = parseCisTx(rawTx);
            if (!parsed || parsed.tx.from !== meAddr) continue;
            if (parsed.memo.type !== "set_username") continue;
            const u = normalizeUsername(
              parsed.memo.username,
              deriveDefaultUsername(meAddr),
              meAddr
            );
            if (parsed.tx.ts >= latestTs) {
              latestTs = parsed.tx.ts;
              latest = u;
            }
          }
          return latest;
        }

        const SURVEY_COOLDOWN_MS = 24 * 60 * 60 * 1000; // 24 hours
        const MAX_SURVEYS_PER_WINDOW = 3;

        function getMySurveyCreationsInWindow(txs, address) {
          if (!address) return [];
          const meAddr = String(address);
          const windowStart = Date.now() - SURVEY_COOLDOWN_MS;
          const times = [];
          for (const rawTx of txs) {
            const parsed = parseCisTx(rawTx);
            if (!parsed || parsed.tx.from !== meAddr) continue;
            if (parsed.memo.type !== "create_survey") continue;
            if (parsed.tx.ts > windowStart) times.push(parsed.tx.ts);
          }
          return times.sort((a, b) => a - b);
        }

        function formatCooldownRemaining() {
          const windowStart = Date.now() - SURVEY_COOLDOWN_MS;
          const recent = mySurveyCreationTimes.filter(t => t > windowStart);
          if (recent.length < MAX_SURVEYS_PER_WINDOW) return null;
          const oldest = Math.min(...recent);
          const diff = (oldest + SURVEY_COOLDOWN_MS) - Date.now();
          if (diff <= 0) return null;
          const pad = (n) => String(n).padStart(2, "0");
          const totalMin = Math.floor(diff / 60000);
          const hh = Math.floor(totalMin / 60);
          const mm = totalMin % 60;
          return `${pad(hh)}h ${pad(mm)}m`;
        }

        let mySurveyCreationTimes = [];

        function computeResults(txs, myAddress, surveyId) {
          const s =
            SURVEYS.find((x) => x.id === surveyId) || SURVEYS[0] || null;
          if (!s) return { counts: {}, voters: [], meEntry: null };
          const optionsByKey = new Map();
          for (const opt of s.options) {
            if (!opt || !opt.key) continue;
            optionsByKey.set(String(opt.key), { ...opt });
          }

          // One custom option per sender: keep the oldest add_option per survey.
          const oldestOptionBySender = new Map(); // sender -> { key,label,ts }
          for (const rawTx of txs) {
            const parsed = parseCisTx(rawTx);
            if (!parsed || parsed.memo.type !== "add_option") continue;
            const sv = parsed.memo.survey == null ? null : String(parsed.memo.survey);
            if (sv !== s.id) continue;
            const optionObj = parsed.memo.option && typeof parsed.memo.option === "object"
              ? parsed.memo.option
              : null;
            const label = optionObj && optionObj.label != null
              ? String(optionObj.label).trim()
              : "";
            if (!label) continue;
            const rawKey = optionObj && optionObj.key != null
              ? String(optionObj.key).trim()
              : slugify(label);
            const { tx } = parsed;
            const key = rawKey || `opt_${last6(tx.from)}_${String(tx.ts)}`;
            const prev = oldestOptionBySender.get(tx.from);
            if (!prev || tx.ts < prev.ts) {
              oldestOptionBySender.set(tx.from, { key, label, ts: tx.ts, from: tx.from });
            }
          }

          // Merge sender-submitted options into survey options with stable unique keys.
          const added = Array.from(oldestOptionBySender.values()).sort((a, b) => a.ts - b.ts);
          for (const it of added) {
            let key = it.key;
            if (optionsByKey.has(key)) key = `${key}_${last6(it.from)}`;
            if (optionsByKey.has(key)) key = `${key}_${String(it.ts).slice(-4)}`;
            optionsByKey.set(key, {
              key,
              label: it.label,
              userAdded: true,
              addedBy: it.from,
            });
          }
          const surveyWithOptions = { ...s, options: Array.from(optionsByKey.values()) };

          // For each sender, track:
          // - latest username claim
          // - latest vote
          const users = new Map(); // from -> { username, usernameTs, voteKey, voteTs }

          for (const rawTx of txs) {
            const parsed = parseCisTx(rawTx);
            if (!parsed) continue;
            const { tx, memo: memoObj } = parsed;

            const entry = users.get(tx.from) || {
              from: tx.from,
              username: deriveDefaultUsername(tx.from),
              usernameTs: 0,
              voteKey: null,
              voteTs: 0,
            };

            if (memoObj.type === "set_username") {
              const u = normalizeUsername(memoObj.username, entry.username, tx.from);
              if (tx.ts >= entry.usernameTs) {
                entry.username = u;
                entry.usernameTs = tx.ts;
              }
              // A username-claim tx should never be treated as a vote.
              users.set(tx.from, entry);
              continue;
            }

            // Vote parsing:
            let voteKey = null;
            if (memoObj.type === "vote") {
              const sv = memoObj.survey == null ? null : String(memoObj.survey);
              const ch =
                memoObj.choice != null
                  ? String(memoObj.choice)
                  : memoObj.vote != null
                    ? String(memoObj.vote)
                    : null;
              if (!sv || sv === s.id) voteKey = ch == null ? null : ch.trim();
            }

            if (
              voteKey &&
              surveyWithOptions.options.some((o) => o.key === voteKey)
            ) {
              if (tx.ts >= entry.voteTs) {
                entry.voteKey = voteKey;
                entry.voteTs = tx.ts;
              }
            }

            users.set(tx.from, entry);
          }

          const counts = {};
          for (const opt of surveyWithOptions.options) counts[opt.key] = 0;
          const voters = [];
          for (const u of users.values()) {
            if (!u.voteKey) continue;
            counts[u.voteKey] = (counts[u.voteKey] || 0) + 1;
            voters.push({ from: u.from, username: u.username, vote: u.voteKey, voteTs: u.voteTs });
          }

          voters.sort((a, b) => b.voteTs - a.voteTs);
          const meKey = myAddress == null ? null : String(myAddress);
          const meEntry = meKey ? users.get(meKey) || null : null;
          const myAddedOption = meKey ? oldestOptionBySender.get(meKey) || null : null;
          const usernameByAddress = new Map();
          for (const u of users.values()) {
            usernameByAddress.set(u.from, u.username);
          }
          return {
            counts,
            voters,
            meEntry,
            survey: surveyWithOptions,
            myAddedOption,
            usernameByAddress,
          };
        }

        const IMAGE_URL_RE = /https?:\/\/\S+\.(?:png|jpe?g|gif|webp|svg|bmp|ico)(?:\?\S*)?/i;
        const ANY_URL_RE = /https?:\/\/\S+/gi;

        /**
         * Parse an option label into text, image URL (if any), and non-image
         * URLs (rendered as clickable links).
         */
        function parseOptionLabel(label) {
          if (!label) return { text: label || "", imageUrl: null, linkUrls: [] };
          const imageMatch = IMAGE_URL_RE.exec(label);
          const imageUrl = imageMatch ? imageMatch[0] : null;

          // Find all non-image URLs.
          const linkUrls = [];
          let match;
          ANY_URL_RE.lastIndex = 0;
          while ((match = ANY_URL_RE.exec(label)) !== null) {
            const u = match[0];
            if (u === imageUrl) continue; // skip the image URL
            linkUrls.push(u);
          }

          // Strip ALL URLs from text.
          let text = label.replace(ANY_URL_RE, " ").replace(/\s{2,}/g, " ").trim();
          return { text, imageUrl, linkUrls };
        }

        function makeOptionImage(url, alt) {
          const img = document.createElement("img");
          img.src = url;
          img.alt = alt || "option image";
          img.style.cssText = "display:block;max-width:100%;max-height:100vw;border-radius:4px;margin-top:6px;object-fit:contain;";
          img.onerror = function () {
            this.replaceWith(document.createTextNode(url));
          };
          return img;
        }

        function makeOptionLinks(urls) {
          if (!urls || urls.length === 0) return null;
          const container = document.createElement("div");
          container.style.cssText = "margin-top:4px;font-size:12px;display:flex;flex-wrap:wrap;gap:4px 8px;";
          for (const url of urls) {
            const a = document.createElement("a");
            a.href = url;
            a.target = "_blank";
            a.rel = "noopener noreferrer";
            a.style.cssText = "color:var(--accent);text-decoration:underline;word-break:break-all;";
            // Stop clicks from bubbling to the parent <button> (which would trigger a vote).
            a.addEventListener("click", (e) => e.stopPropagation());
            // Show a shorter display text.
            try {
              const u = new URL(url);
              a.textContent = u.hostname + (u.pathname.length > 1 ? u.pathname.slice(0, 30) : "");
              if (u.pathname.length > 30) a.textContent += "…";
            } catch (_) {
              a.textContent = url.slice(0, 50) + (url.length > 50 ? "…" : "");
            }
            container.appendChild(a);
          }
          return container;
        }

        function renderResults(res) {
          if (!res || !res.survey) return;
          const s = res.survey;
          const c = res.counts;
          const total = s.options.reduce((acc, o) => acc + (c[o.key] || 0), 0);
          const pct = (n) => (total > 0 ? Math.round((n / total) * 100) : 0);
          if (resultsBarsEl) resultsBarsEl.textContent = "";
          if (resultsBarsEl && s.options.length === 0) {
            const empty = document.createElement("p");
            empty.className = "muted";
            empty.style.cssText = "font-size:13px;margin:8px 0;";
            empty.textContent = "No options yet — add an option above!";
            resultsBarsEl.appendChild(empty);
          }
          if (resultsBarsEl) {
            for (const opt of s.options) {
              const count = c[opt.key] || 0;
              const row = document.createElement("button");
              row.className = "btn";
              row.style.width = "100%";
              row.style.display = "block";
              row.style.textAlign = "left";
              row.setAttribute("data-choice", opt.key);
              row.disabled = sending || !!s.archived;
              row.addEventListener("click", async () => {
                if (sending || s.archived) return;
                try {
                  await voteFlow(opt.key, opt.label);
                } catch (e) {
                  console.error(e);
                } finally {
                  setSending(false);
                }
              });
              const parsed = parseOptionLabel(opt.label);
              // Top: text + vote count
              const header = document.createElement("div");
              header.className = "row";
              header.style.cssText = "justify-content:space-between;align-items:flex-start;";
              const left = document.createElement("strong");
              left.textContent = parsed.text || opt.key;
              const right = document.createElement("span");
              right.className = "muted";
              right.style.cssText = "flex:0 0 auto;margin-left:8px;";
              const countCode = document.createElement("code");
              countCode.textContent = count;
              right.appendChild(countCode);
              header.appendChild(left);
              header.appendChild(right);
              row.appendChild(header);
              // Attribution for user-added options
              if (opt.userAdded && opt.addedBy) {
                const addedBy = document.createElement("div");
                addedBy.className = "muted";
                addedBy.style.cssText = "font-size:11px;margin:6px 0;";
                const name = (res.usernameByAddress && res.usernameByAddress.get(opt.addedBy))
                  || deriveDefaultUsername(opt.addedBy);
                addedBy.textContent = "Added by " + name;
                row.appendChild(addedBy);
              }
              // Middle: vote bar
              const bar = document.createElement("div");
              bar.className = "bar";
              if (count === 0) bar.style.borderColor = "transparent";
              const inner = document.createElement("div");
              inner.style.width = pct(count) + "%";
              bar.appendChild(inner);
              row.appendChild(bar);
              // Bottom: image (if any)
              if (parsed.imageUrl) {
                row.appendChild(makeOptionImage(parsed.imageUrl, parsed.text));
              }
              // Links (non-image URLs)
              const linksEl = makeOptionLinks(parsed.linkUrls);
              if (linksEl) row.appendChild(linksEl);
              resultsBarsEl.appendChild(row);
            }
          }
          currentOptionByKey = new Map();
          for (const opt of s.options) {
            currentOptionByKey.set(opt.key, opt);
          }

        }

        function isSurveyCooldownActive() {
          const windowStart = Date.now() - SURVEY_COOLDOWN_MS;
          const recent = mySurveyCreationTimes.filter(t => t > windowStart);
          return recent.length >= MAX_SURVEYS_PER_WINDOW;
        }

        function updateSurveyCooldownUi() {
          const remaining = formatCooldownRemaining();
          const onCooldown = !!remaining;
          if (surveyCooldownHintEl) {
            if (onCooldown) {
              surveyCooldownHintEl.textContent = `You can create another survey in ${remaining}.`;
              show(surveyCooldownHintEl, true);
            } else {
              show(surveyCooldownHintEl, false);
            }
          }
          // Disable form inputs and save button while on cooldown
          if (saveSurveyBtn) setDisabled(saveSurveyBtn, sending || onCooldown);
          if (newSurveyTitleEl) setDisabled(newSurveyTitleEl, sending || onCooldown);
          if (newSurveyQuestionEl) setDisabled(newSurveyQuestionEl, sending || onCooldown);
          getSurveyOptionInputs().forEach((inp) => setDisabled(inp, sending || onCooldown));
          if (addSurveyOptionBtn) setDisabled(addSurveyOptionBtn, sending || onCooldown);
          if (newSurveyDurationEl) setDisabled(newSurveyDurationEl, sending || onCooldown);
        }

        async function refreshLoopOnce() {
          try {
            const txs = await getCisTransactions(400);
            const latestUsername = getMyLatestUsername(txs, me);
            if (latestUsername) {
              myUsername = latestUsername;
              setUsernameUi(myUsername);
            }
            rebuildSurveysFromTransactions(txs);
            latestTxs = txs;
            renderSurveyList();

            // Update survey creation cooldown
            mySurveyCreationTimes = getMySurveyCreationsInWindow(txs, me);
            updateSurveyCooldownUi();

            if (currentSurveyId && !SURVEYS.some((s) => s.id === currentSurveyId)) {
              navigateToList();
            }
            if (currentSurveyId) {
              const res = computeResults(txs, me, currentSurveyId);
              renderResults(res);
              // Update detail-screen countdown
              if (surveyCountdownEl) {
                if (res.survey.archived) {
                  delete surveyCountdownEl.dataset.expires;
                  surveyCountdownEl.textContent = formatArchivedDate(res.survey.expiresAtMs);
                  surveyCountdownEl.style.display = "";
                } else if (res.survey.expiresAtMs) {
                  surveyCountdownEl.dataset.expires = res.survey.expiresAtMs;
                  surveyCountdownEl.textContent = "⏱ " + formatCountdown(res.survey.expiresAtMs);
                  surveyCountdownEl.style.display = "";
                } else {
                  delete surveyCountdownEl.dataset.expires;
                  surveyCountdownEl.style.display = "none";
                }
              }
              if (addOptionToggleBtn) {
                addOptionToggleBtn.style.display = res.survey.archived ? "none" : "";
              }
              myAddedOptionBySurvey[currentSurveyId] = res.myAddedOption || null;
              const addOptionOpen = addOptionPanelEl && !addOptionPanelEl.classList.contains("hide");
              if (addOptionHintEl) {
                if (res.myAddedOption) {
                  addOptionHintEl.textContent = `You already added: "${res.myAddedOption.label}"`;
                } else {
                  addOptionHintEl.textContent = "You can add one option for this survey.";
                }
              }
              if (newOptionInputEl) {
                // Don't clear the input while the user has the panel open and is typing.
                if (!addOptionOpen) newOptionInputEl.value = "";
                setDisabled(newOptionInputEl, !!res.myAddedOption || sending || !!res.survey.archived);
              }
              if (addOptionToggleBtn) {
                setDisabled(addOptionToggleBtn, !!res.myAddedOption || sending || !!res.survey.archived);
              }
              if (saveOptionBtn) {
                setDisabled(
                  saveOptionBtn,
                  !!res.myAddedOption || sending || !!res.survey.archived
                );
              }
              if (cancelOptionBtn) setDisabled(cancelOptionBtn, sending);
              // Only collapse the panel on refresh if it isn't currently open for editing.
              if (!addOptionOpen && (res.myAddedOption || res.survey.archived)) {
                show(addOptionPanelEl, false);
              }

              // Also reflect the current user's latest vote from chain state.
              if (res.meEntry && res.meEntry.voteKey) {
                latestVoteKey = res.meEntry.voteKey;
                setSelectedVote(res.meEntry.voteKey);
                if (res.meEntry.username) {
                  myUsername = String(res.meEntry.username);
                  setUsernameUi(myUsername);
                }
              } else {
                latestVoteKey = null;
                setSelectedVote(null);
              }
            }
          } catch (e) {
            console.error(e);
          }
        }

        function navigateToList() {
          currentSurveyId = null;
          show(screenActiveList, true);
          show(screenArchivedList, SURVEYS.some((s) => !!s.archived));
          show(screenSurvey, false);
          if (backBtn) backBtn.style.display = "none";
        }

        function navigateToSurvey(id) {
          currentSurveyId = id;
          const s = currentSurvey();
          if (!s) return;
          show(screenActiveList, false);
          show(screenArchivedList, false);
          show(screenSurvey, true);
          if (backBtn) backBtn.style.display = "";
          if (surveyTitleEl) surveyTitleEl.textContent = s.title;
          if (surveyQuestionEl) surveyQuestionEl.textContent = s.question;
          if (surveyCreatedByEl) {
            const creatorName = (s.createdBy && GLOBAL_USERNAMES.get(s.createdBy))
              || (s.createdBy ? deriveDefaultUsername(s.createdBy) : "unknown");
            surveyCreatedByEl.textContent = "Created by " + creatorName;
          }
          if (surveyCountdownEl) {
            if (s.archived) {
              delete surveyCountdownEl.dataset.expires;
              surveyCountdownEl.textContent = formatArchivedDate(s.expiresAtMs);
              surveyCountdownEl.style.display = "";
            } else if (s.expiresAtMs) {
              surveyCountdownEl.dataset.expires = s.expiresAtMs;
              surveyCountdownEl.textContent = "⏱ " + formatCountdown(s.expiresAtMs);
              surveyCountdownEl.style.display = "";
            } else {
              delete surveyCountdownEl.dataset.expires;
              surveyCountdownEl.style.display = "none";
            }
          }
          if (addOptionHintEl) addOptionHintEl.textContent = "You can add one option for this survey.";
          show(addOptionPanelEl, false);
          if (addOptionToggleBtn) {
            addOptionToggleBtn.style.display = s.archived ? "none" : "";
            setDisabled(addOptionToggleBtn, !!s.archived);
          }
          if (newOptionInputEl) {
            newOptionInputEl.value = "";
            setDisabled(newOptionInputEl, !!s.archived);
          }
          if (saveOptionBtn) setDisabled(saveOptionBtn, !!s.archived);
          if (cancelOptionBtn) setDisabled(cancelOptionBtn, false);
        }

        function countUniqueVoters(txs, surveyId) {
          const voters = new Set();
          for (const rawTx of txs) {
            const parsed = parseCisTx(rawTx);
            if (!parsed || parsed.memo.type !== "vote") continue;
            const sv = parsed.memo.survey == null ? null : String(parsed.memo.survey);
            if (sv !== surveyId) continue;
            voters.add(parsed.tx.from);
          }
          return voters.size;
        }

        function renderSurveyList() {
          if (!activeSurveyListEl || !archivedSurveyListEl) return;
          activeSurveyListEl.textContent = "";
          archivedSurveyListEl.textContent = "";

          const active = SURVEYS.filter((s) => !s.archived);
          const archived = SURVEYS.filter((s) => !!s.archived);

          // Hide the archived container entirely when there are no archived surveys
          // (but don't re-show it if we're currently viewing a survey detail)
          if (!currentSurveyId) {
            show(screenArchivedList, archived.length > 0);
          }

          if (!active.length) {
            const empty = document.createElement("div");
            empty.className = "muted";
            empty.textContent = "No active surveys.";
            activeSurveyListEl.appendChild(empty);
          }
          // Helper: build a survey-card button using DOM methods (avoids innerHTML XSS).
          function buildSurveyCard(s, badgeText, badgeClass) {
            const b = document.createElement("button");
            b.className = "btn";

            const topRow = document.createElement("div");
            topRow.style.cssText = "display:flex;justify-content:space-between;align-items:center;";
            const titleEl = document.createElement("div");
            titleEl.style.fontWeight = "600";
            titleEl.textContent = s.title;
            topRow.appendChild(titleEl);
            if (badgeText) {
              const badge = document.createElement("span");
              badge.className = badgeClass || "muted";
              badge.style.cssText = "font-size:11px;font-variant-numeric:tabular-nums;white-space:nowrap;margin-left:8px;";
              badge.textContent = badgeText;
              if (s.expiresAtMs && !s.archived) {
                badge.classList.add("countdownTick");
                badge.dataset.expires = s.expiresAtMs;
              }
              topRow.appendChild(badge);
            }

            const botRow = document.createElement("div");
            botRow.className = "muted";
            botRow.style.cssText = "margin-top:4px;display:flex;justify-content:space-between;align-items:center;";
            const questionEl = document.createElement("span");
            questionEl.textContent = s.question;
            const votes = countUniqueVoters(latestTxs, s.id);
            const votesEl = document.createElement("span");
            votesEl.style.cssText = "font-size:11px;white-space:nowrap;margin-left:8px;";
            votesEl.textContent = votes === 1 ? "1 vote" : `${votes} votes`;
            botRow.appendChild(questionEl);
            botRow.appendChild(votesEl);

            const createdByRow = document.createElement("div");
            createdByRow.className = "muted";
            createdByRow.style.cssText = "font-size:11px;margin:6px 0 0;";
            const creatorName = (s.createdBy && GLOBAL_USERNAMES.get(s.createdBy))
              || (s.createdBy ? deriveDefaultUsername(s.createdBy) : "unknown");
            createdByRow.textContent = "Created by " + creatorName;

            b.appendChild(topRow);
            b.appendChild(botRow);
            b.appendChild(createdByRow);
            b.addEventListener("click", () => {
              navigateToSurvey(s.id);
              refreshLoopOnce();
            });
            return b;
          }

          for (const s of active) {
            const countdown = s.expiresAtMs ? "⏱ " + formatCountdown(s.expiresAtMs) : "";
            activeSurveyListEl.appendChild(buildSurveyCard(s, countdown, "muted"));
          }

          for (const s of archived) {
            archivedSurveyListEl.appendChild(
              buildSurveyCard(s, formatArchivedDate(s.expiresAtMs), "muted")
            );
          }
        }

        async function init() {
          attachRubberBand();
          SURVEYS = [];

          try {
            me = await getNodeAddress();
          } catch (_) {}
          myUsername = deriveDefaultUsername(me);
          setUsernameUi(myUsername);

          // Discover chain ID so explorer API and bridge getTransactions work
          try {
            chainId = await discoverChainId();
            window.usernode = window.usernode || {};
            window.usernode.transactionsBaseUrl = `${EXPLORER_BASE}/${chainId}`;
          } catch (e) {
            console.warn("Could not discover chain ID:", e);
          }

          // Check if the user already has a username on-chain
          try {
            const txs = await getCisTransactions(400);
            const latestUsername = getMyLatestUsername(txs, me);
            if (latestUsername) {
              myUsername = latestUsername;
              setUsernameUi(myUsername);
            }
          } catch (e) {
            console.warn("Could not fetch initial username:", e);
          }

          setSending(false);
          renderSurveyList();
          navigateToList();

          if (backBtn) {
            backBtn.addEventListener("click", () => {
              navigateToList();
            });
          }
          if (headerUsernameBtn) {
            headerUsernameBtn.addEventListener("click", () => {
              if (sending) return;
              navigateToList();
              const opening = setUsernamePanel && setUsernamePanel.classList.contains("hide");
              show(setUsernamePanel, !!opening);
              if (opening) clearUsernameForm();
            });
          }
          if (cancelUsernameBtn) {
            cancelUsernameBtn.addEventListener("click", () => {
              show(setUsernamePanel, false);
            });
          }
          if (saveUsernameBtn) {
            saveUsernameBtn.addEventListener("click", async () => {
              try {
                setSending(true);
                await setUsernameFlow(usernameInputEl ? usernameInputEl.value : "");
                show(setUsernamePanel, false);
              } catch (e) {
                const msg = e && e.message ? e.message : String(e);
                window.alert(msg);
              } finally {
                setSending(false);
              }
            });
          }
          if (addOptionToggleBtn) {
            addOptionToggleBtn.addEventListener("click", () => {
              if (sending || !currentSurveyId) return;
              const opening = addOptionPanelEl && addOptionPanelEl.classList.contains("hide");
              show(addOptionPanelEl, !!opening);
              if (!opening && newOptionInputEl) newOptionInputEl.value = "";
            });
          }
          if (cancelOptionBtn) {
            cancelOptionBtn.addEventListener("click", () => {
              show(addOptionPanelEl, false);
              if (newOptionInputEl) newOptionInputEl.value = "";
            });
          }
          if (saveOptionBtn) {
            saveOptionBtn.addEventListener("click", async () => {
              if (sending || !currentSurveyId) return;
              try {
                setSending(true);
                await addOptionFlow(newOptionInputEl ? newOptionInputEl.value : "");
                show(addOptionPanelEl, false);
                if (newOptionInputEl) newOptionInputEl.value = "";
              } catch (e) {
                const msg = e && e.message ? e.message : String(e);
                window.alert(msg);
              } finally {
                setSending(false);
              }
            });
          }

          if (addSurveyOptionBtn) {
            addSurveyOptionBtn.addEventListener("click", () => {
              addSurveyOptionField("");
            });
          }
          if (addSurveyBtn) {
            addSurveyBtn.addEventListener("click", () => {
              const opening = addSurveyPanel && addSurveyPanel.classList.contains("hide");
              show(addSurveyPanel, !!opening);
              if (opening) {
                updateSurveyCooldownUi();
              } else {
                clearAddSurveyForm();
              }
            });
          }
          if (cancelSurveyBtn) {
            cancelSurveyBtn.addEventListener("click", () => {
              show(addSurveyPanel, false);
              clearAddSurveyForm();
            });
          }
          if (saveSurveyBtn) {
            saveSurveyBtn.addEventListener("click", async () => {
              try {
                if (isSurveyCooldownActive()) {
                  const remaining = formatCooldownRemaining() || "some time";
                  throw new Error(`You can create another survey in ${remaining}.`);
                }
                const survey = createSurveyFromForm();
                setSending(true);
                const memo = makeMemo({
                  app: "cis",
                  type: "create_survey",
                  survey: {
                    id: survey.id,
                    title: survey.title,
                    question: survey.question,
                    active_duration_ms: survey.activeDurationMs,
                    options: survey.options,
                  },
                });
                await sendTransaction(CIS_APP_PUBKEY, 1, memo, TX_SEND_OPTS);
                await refreshLoopOnce();
                show(addSurveyPanel, false);
                clearAddSurveyForm();
              } catch (e) {
                const msg = e && e.message ? e.message : String(e);
                // Keep this lightweight; no extra status area needed.
                window.alert(msg);
              } finally {
                setSending(false);
              }
            });
          }

          // Set up initial option fields for the create-survey form.
          initSurveyOptionFields();

          // Results polling
          await refreshLoopOnce();
          window.setInterval(refreshLoopOnce, 4000);

          // 1-second ticker for sub-hour countdowns and cooldown hint
          window.setInterval(() => {
            document.querySelectorAll(".countdownTick[data-expires]").forEach((el) => {
              const exp = Number(el.dataset.expires);
              if (exp) el.textContent = "⏱ " + formatCountdown(exp);
            });
            if (surveyCountdownEl && surveyCountdownEl.dataset.expires) {
              const exp = Number(surveyCountdownEl.dataset.expires);
              if (exp) surveyCountdownEl.textContent = "⏱ " + formatCountdown(exp);
            }
            // Keep cooldown hint fresh if the add-survey panel is open
            if (addSurveyPanel && !addSurveyPanel.classList.contains("hide")) {
              updateSurveyCooldownUi();
            }
          }, 1000);
        }

        init();
      })();
    </script>
  </body>
</html>